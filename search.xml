<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CSS溢出</title>
      <link href="/2020/05/18/css-yi-chu/"/>
      <url>/2020/05/18/css-yi-chu/</url>
      
        <content type="html"><![CDATA[<p>我们知道，CSS中万物皆盒，因此我们可以通过给<code>width</code>和<code>height</code>（或者 <code>inline-size</code> 和 <code>block-size</code>）赋值的方式来约束盒子的尺寸。<strong>溢出</strong>是在你往盒子里面塞太多东西的时候发生的，所以盒子里面的东西也不会老老实实待着。</p><p>CSS默认处理溢出的方式，不是去隐藏这些溢出的内容，而是将其溢出。因为这样保证了数据的完整性，也会提醒开发者进行修改。</p><h1 id="overflow-属性">Overflow 属性</h1><ol type="1"><li><p><code>overflow</code>的默认值为<code>visible</code>，即将溢出的内容可视化，这就是我们的内容溢出的时候，我们在默认情况下看到它们的原因。</p></li><li><p>如果想要将内容裁减掉，使用<code>overflow: hidden</code>：</p><p><img src="/2020/05/18/css-yi-chu/CSS溢出_2020-05-18-23-36-30.png" alt="overflow的hidden值"><br></p></li><li><p>如果我们希望加一个滚动条，使得能够避免内容的消失，使用<code>overflow: scroll</code>:</p><p><img src="/2020/05/18/css-yi-chu/CSS溢出_2020-05-18-23-41-14.png" alt="overflow的scroll值"><br></p><p>如果只想在上下方向加滚动条，可以使用<code>overflow-y: scroll</code>（同样类似的，也有<code>overflow-x</code>）</p><p><img src="/2020/05/18/css-yi-chu/CSS溢出_2020-05-19-00-01-14.png" alt="overflow-y:scroll"><br></p><p>但这有个坏处，如果内容用不着滚动条，滚动条也不会消失！！</p><p><img src="/2020/05/18/css-yi-chu/CSS溢出_2020-05-19-00-03-23.png" alt="overflow没有消失"><br></p><p>当然，像其他属性一样，<code>overflow: scroll hidden</code>代表对<code>x</code>轴设置<code>scroll</code>，对y轴设置<code>hidden</code>。</p></li><li><p>如果想要移除上面的缺点，使内容多的时候自动出现滚动条，内容少的时候滚动条消失，就要使用<code>overflow: auto</code>。</p></li></ol><p><strong>实际上，现代CSS布局会很好的处理溢出，所以没有必要太过注意。</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MDN学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS文本</title>
      <link href="/2020/05/18/css-wen-ben/"/>
      <url>/2020/05/18/css-wen-ben/</url>
      
        <content type="html"><![CDATA[<h1 id="书写模式">书写模式</h1><p>CSS中的书写模式是指文本的排列方向是横向还是纵向的。<code>writing-mode</code> 属性使我们从一种模式切换到另一种模式。为此，你不必使用一种竖向的语言——你还可以更改部分文字的方向以实现创新性的布局。</p><p><code>writing-mode</code>的三个值分别是：</p><ul><li><code>horizontal-tb</code>: 显示方向从上至下。对应的文本方向是横向的。</li><li><code>vertical-rl</code>: 显示方向从右向左。对应的文本方向是纵向的。</li><li><code>vertical-lr</code>: 显示方向从左向右。对应的文本方向是纵向的。</li></ul><p>因此，<code>writing-mode</code>属性实际上设定的是页面上块级元素的显示方向——要么是从上到下，要么是从右到左，要么是从左到右。而这又决定了文本的方向。</p><h2 id="与块级元素显示模式的关系">与块级元素显示模式的关系</h2><p>块级显示和内联显示与文本的书写模式（而非屏幕的物理显示）密切相关。如果你使用书写模式的显示是横向的，如英文，那么块在页面上的显示就是从上到下的。当我们切换书写模式时，我们也在改变块和内联文本的方向。<code>horizontal-tb</code>书写模式下块的方向是从上到下的横向的，而 <code>vertical-rl</code>书写模式下块的方向是从右到左的纵向的。因此，块维度指的总是块在页面书写模式下的显示方向。而内联维度指的总是文本方向。</p><p><strong>块的方向和文本的方向是绑定在一起的，我们使用<code>writing-mode</code>既可以来设定显示方向，也可以用来设定文本方向。</strong></p><h2 id="逻辑属性和逻辑值">逻辑属性和逻辑值</h2><p>现在我们一个盒子使用了<code>horizontal-tb</code>，一个盒子使用了<code>vertical-rl</code>，现在我们希望得到如下的效果：</p><p><img src="/2020/05/18/css-wen-ben/CSS文本_2020-05-18-22-36-34.png"><br></p><p>是否可以直接将两个盒子的width都设置为150px？？</p><p>实际上如此设置我们会得到下面的结果：</p><p><img src="/2020/05/18/css-wen-ben/CSS文本_2020-05-18-22-37-31.png"><br></p><p>这是为什么？？？</p><p><strong>这是因为，虽然两个盒子内部的文本方向、显示方向都变了，但<code>width</code>和<code>height</code>的定义没有变，都还是上下边界的长度。这里实际上我们需要设定为150px的是第一个盒子的宽，第二个盒子的高。</strong></p><p>但显然这比较麻烦，所以CSS提供了一系列映射属性：<code>inline-size</code>和<code>block-size</code>来完成这个任务。</p><p><code>inline-size</code>代替我们的<code>width</code>，<code>block-size</code>代替我们的<code>height</code>，这时候我们就可以使用一个属性来改变两个boxes的“宽”了。</p><p>同样，对于<code>margin-top</code>、<code>padding-left</code>和<code>border-bttom</code>等，也有对应的逻辑属性：</p><ul><li><code>margin-top</code> &lt;--&gt; <code>margin-block-start</code></li><li><code>padding-left</code> &lt;--&gt; <code>padding-inline-start</code></li><li><code>border-bottom</code> &lt;--&gt; <code>border-block-end</code></li><li>...</li></ul><p><strong>如果你用<code>writing-mode</code>把盒子<code>.box</code>的书写模式改为<code>vertical-rl</code>，你将会看到尽管盒子的物理方向变了，盒子的物理属性仍然没变，然而逻辑属性会随着书写模式一起改变。</strong></p><p>以上我们看到的是逻辑属性，还有一些是逻辑值，比如：</p><ul><li><code>top</code> &lt;--&gt; <code>block-start</code></li><li><code>right</code> &lt;--&gt; <code>inline-end</code></li><li><code>bottom</code> &lt;--&gt; <code>block-end</code></li><li><code>left</code> &lt;--&gt; <code>inline-start</code></li></ul><p>这些也正好是上面属性值的命名规则。</p><blockquote><p>如果你并没有应用多种书写模式，那么现在你可能更倾向于使用物理属性，因为这些在你使用弹性布局和网格布局时非常有用。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MDN学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS盒子模型</title>
      <link href="/2020/05/17/css-he-zi-mo-xing/"/>
      <url>/2020/05/17/css-he-zi-mo-xing/</url>
      
        <content type="html"><![CDATA[<p>在CSS中，将所有的元素都看做是一个box。</p><h1 id="块级盒子block-box和内联盒子inline-box">块级盒子（block box）和内联盒子（inline box）</h1><p>两者在page flows和元素间关系表现出不同的行为。</p><p>对于block box：</p><ul><li>盒子会在内联的方向上扩展并占据父容器在该方向上的所有可用空间，在绝大数情况下意味着盒子会和父容器一样宽。</li><li>每个盒子都会换行（独占一行）。</li><li><code>width</code> 和 <code>height</code> 属性可以发挥作用。</li><li>内边距（padding）, 外边距（margin） 和 边框（border） 会将其他元素从当前盒子周围“推开”。</li></ul><p>对于inline box：</p><ul><li>盒子不会产生换行。</li><li><code>width</code> 和 <code>height</code> 属性将不起作用。</li><li>内边距、外边距以及边框会被应用但是不会把其他处于 inline 状态的盒子推开。（也就是说，会有内外边距，也会有边框，但其他相邻元素会“压在”其上面）</li></ul><p>可以使用<code>display: block/inline</code>来进行控制外部显示类型。</p><blockquote><p>外部显示类型通过<code>display</code>来控制，让box是block还是inline。<br>同样的，盒模型还有内部显示类型，决定了盒子内的元素如何布局。<br>默认是正常文档流，即盒子内的元素根据其是block还是inline来进行布局，规则如上所示。但我们可以使用<code>display: flex</code>，这样外部显示类型是<code>block</code>，但内部显示类型变成了<code>flex</code>，则内部的元素将采用弹性盒子（Flexbox）的规则进行布局。（这将是CSS布局的主要内容）</p></blockquote><blockquote><p>下面将专注于外部显示类型。</p></blockquote><h1 id="盒模型block">盒模型（block）</h1><p>只有block才应用了盒模型的全部，inline只是应用了盒模型的一部分特性，从而表现出不同。</p><h2 id="盒模型的各个部分">盒模型的各个部分</h2><p><img src="/2020/05/17/css-he-zi-mo-xing/CSS盒子模型_2020-05-17-15-09-44.png" alt="盒模型"><br></p><ul><li>Content box: 这个区域是用来显示内容，大小可以通过设置 <code>width</code> 和 <code>height</code>。</li><li>Padding box: 包围在内容区域外部的空白区域； 大小通过 <code>padding</code> 相关属性设置。</li><li>Border box: 边框盒包裹内容和内边距。大小通过 <code>border</code> 相关属性设置。</li><li>Margin box: 这是最外面的区域，是盒子和其他元素之间的空白区域。大小通过 <code>margin</code> 相关属性设置。</li></ul><blockquote><p>注意，盒子的大小是<code>width</code>和<code>height</code>再加上<code>padding</code>和<code>border</code>。<code>margin</code>没有算入内，<code>margin</code>不影响盒子的大小，只影响盒子所占的空间的大小。</p></blockquote><p>例： <img src="/2020/05/17/css-he-zi-mo-xing/CSS盒子模型_2020-05-17-16-29-48.png" alt="block示例"></p><p>当然，如果感觉去进行计算很麻烦，可以使用替代盒模型（IE）。即给元素加入下列的属性，则设定的<code>height</code>和<code>width</code>是<code>content</code>+<code>padding</code>+<code>border</code>的大小，即可见大小。</p><div class="sourceCode" id="cb1"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb1-1"><a href="#cb1-1"></a><span class="fu">.box</span> {</span><span id="cb1-2"><a href="#cb1-2"></a>  <span class="kw">box-sizing</span>: <span class="dv">border-box</span><span class="op">;</span></span><span id="cb1-3"><a href="#cb1-3"></a>}</span></code></pre></div><p>如果想要所有的元素都使用替代盒模型，则可以使用以下代码（就是让所有的元素都继承<code>box-sizing</code>属性）：</p><div class="sourceCode" id="cb2"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb2-1"><a href="#cb2-1"></a>html {</span><span id="cb2-2"><a href="#cb2-2"></a>  <span class="kw">box-sizing</span>: <span class="dv">border-box</span><span class="op">;</span></span><span id="cb2-3"><a href="#cb2-3"></a>}</span><span id="cb2-4"><a href="#cb2-4"></a><span class="op">*,</span> <span class="op">*</span><span class="in">::before</span><span class="op">,</span> <span class="op">*</span><span class="in">::after</span> {</span><span id="cb2-5"><a href="#cb2-5"></a>  <span class="kw">box-sizing</span>: <span class="bu">inherit</span><span class="op">;</span></span><span id="cb2-6"><a href="#cb2-6"></a>}</span></code></pre></div><h2 id="内外边距和边框的声明方式">内外边距和边框的声明方式</h2><h3 id="margin"><code>margin</code></h3><div class="sourceCode" id="cb3"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb3-1"><a href="#cb3-1"></a><span class="fu">.box</span> {</span><span id="cb3-2"><a href="#cb3-2"></a>  <span class="kw">margin-top</span>: <span class="dv">-60</span><span class="dt">px</span><span class="op">;</span></span><span id="cb3-3"><a href="#cb3-3"></a>  <span class="kw">margin-right</span>: <span class="dv">30</span><span class="dt">px</span><span class="op">;</span></span><span id="cb3-4"><a href="#cb3-4"></a>  <span class="kw">margin-bottom</span>: <span class="dv">40</span><span class="dt">px</span><span class="op">;</span></span><span id="cb3-5"><a href="#cb3-5"></a>  <span class="kw">margin-left</span>: <span class="dv">4</span><span class="dt">em</span><span class="op">;</span></span><span id="cb3-6"><a href="#cb3-6"></a>}</span></code></pre></div><p>要点：</p><ol type="1"><li><strong>外边距相接</strong>，两个相邻的元素，都设置了外边距，则两个盒子（指的是两个盒子的border）之间的距离是两个外边距的最大值而不是相加值。</li><li><code>margin</code>可以为负（<code>border</code>和<code>padding</code>是不可以为负的）。当为负值时，如果父元素并没有设置<code>heigth</code>或<code>width</code>，则这会对父元素产生压缩效应。同样的，盒子部分+margin共同构成父元素的content，在父元素没有设置<code>height</code>或<code>width</code>时共同决定父元素的<code>height</code>和<code>width</code>，此时较大的<code>margin</code>也会撑开父元素。</li><li>当父元素设置了<code>height</code>和<code>width</code>时，则变化<code>margin</code>的值只是类似：在以父元素左上边界为基准的情况下进行的移动。</li></ol><h3 id="border"><code>border</code></h3><p>单独设置：</p><div class="sourceCode" id="cb4"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb4-1"><a href="#cb4-1"></a>border-top-width</span><span id="cb4-2"><a href="#cb4-2"></a>border-top-style</span><span id="cb4-3"><a href="#cb4-3"></a>border-top-color</span><span id="cb4-4"><a href="#cb4-4"></a>border-right-width</span><span id="cb4-5"><a href="#cb4-5"></a>border-right-style</span><span id="cb4-6"><a href="#cb4-6"></a>border-right-color</span><span id="cb4-7"><a href="#cb4-7"></a>border-bottom-width</span><span id="cb4-8"><a href="#cb4-8"></a>border-bottom-style</span><span id="cb4-9"><a href="#cb4-9"></a>border-bottom-color</span><span id="cb4-10"><a href="#cb4-10"></a>border-left-width</span><span id="cb4-11"><a href="#cb4-11"></a>border-left-style</span><span id="cb4-12"><a href="#cb4-12"></a>border-left-color</span></code></pre></div><p>一起设置4个边框的单个属性：</p><div class="sourceCode" id="cb5"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb5-1"><a href="#cb5-1"></a>border-width</span><span id="cb5-2"><a href="#cb5-2"></a>border-style</span><span id="cb5-3"><a href="#cb5-3"></a>border-color</span></code></pre></div><p>一次设置单个变量的3个属性：</p><div class="sourceCode" id="cb6"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb6-1"><a href="#cb6-1"></a>border-top</span><span id="cb6-2"><a href="#cb6-2"></a>border-right</span><span id="cb6-3"><a href="#cb6-3"></a>border-bottom</span><span id="cb6-4"><a href="#cb6-4"></a>border-left</span></code></pre></div><h3 id="padding"><code>padding</code></h3><div class="sourceCode" id="cb7"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb7-1"><a href="#cb7-1"></a>padding-top</span><span id="cb7-2"><a href="#cb7-2"></a>padding-right</span><span id="cb7-3"><a href="#cb7-3"></a>padding-bottom</span><span id="cb7-4"><a href="#cb7-4"></a>padding-left</span></code></pre></div><h1 id="内联模式inline">内联模式（inline）</h1><p>在inline box中，<code>height</code>和<code>width</code>不会生效，但<code>padding</code>、<code>border</code>和<code>margin</code>是生效的，但不会改变其和其他inline boxes的关系。</p><p><img src="/2020/05/17/css-he-zi-mo-xing/CSS盒子模型_2020-05-17-16-13-46.png" alt="inline示例"><br></p><blockquote><p>inline的盒子所占据的大小只会在左右方向上产生影响，在上下不会有影响。所以我们看到的是左右撑开了，但上下没有撑开。</p></blockquote><h1 id="行内块模式inline-block">行内块模式（inline-block）</h1><p>一个元素使用 <code>display: inline-block</code>，实现我们需要的block的部分效果：</p><ul><li>设置<code>width</code> 和<code>height</code> 属性会生效。</li><li><code>padding</code>, <code>margin</code>, 以及<code>border</code> 会推开其他元素。</li></ul><p>但是，它不会跳转到新行，如果显式添加<code>width</code> 和<code>height</code> 属性，它只会变得比其内容更大。</p><p><img src="/2020/05/17/css-he-zi-mo-xing/CSS盒子模型_2020-05-17-16-17-18.png" alt="inline-block示例"><br></p><p>当您想要通过添加内边距使链接具有更大的命中区域时，这是很有用的。<code>&lt;a&gt;</code>是像<code>&lt;span&gt;</code>一样的内联元素；你可以使用<code>display: inline-block</code>来设置内边距，让用户更容易点击链接。这种情况在导航栏中很常见。</p><h1 id="背景">背景</h1><div class="sourceCode" id="cb8"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb8-1"><a href="#cb8-1"></a><span class="fu">.box</span> { </span><span id="cb8-2"><a href="#cb8-2"></a>  <span class="kw">background</span>: <span class="fu">linear-gradient(</span><span class="dv">105</span><span class="dt">deg</span><span class="op">,</span> rgba(<span class="dv">255</span><span class="op">,</span><span class="dv">255</span><span class="op">,</span><span class="dv">255</span><span class="op">,</span><span class="dv">.2</span><span class="fu">)</span> <span class="dv">39</span><span class="dt">%</span><span class="op">,</span> <span class="fu">rgba(</span><span class="dv">51</span><span class="op">,</span><span class="dv">56</span><span class="op">,</span><span class="dv">57</span><span class="op">,</span><span class="dv">1</span><span class="fu">)</span> <span class="dv">96</span><span class="dt">%</span>) <span class="dv">center</span> <span class="dv">center</span> / <span class="dv">400</span><span class="dt">px</span> <span class="dv">200</span><span class="dt">px</span> <span class="dv">no-repeat</span><span class="op">,</span> </span><span id="cb8-3"><a href="#cb8-3"></a>  <span class="fu">url(</span><span class="st">big-star.png</span><span class="fu">)</span> <span class="dv">center</span> <span class="dv">no-repeat</span><span class="op">,</span> <span class="cn">rebeccapurple</span><span class="op">;</span> </span><span id="cb8-4"><a href="#cb8-4"></a>} </span></code></pre></div><p>以上是可以控制的背景所有的属性，<em>我想我们应该不会这么写代码的。</em></p><h2 id="背景颜色">背景颜色</h2><div class="sourceCode" id="cb9"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb9-1"><a href="#cb9-1"></a><span class="fu">.box</span> {</span><span id="cb9-2"><a href="#cb9-2"></a>  <span class="kw">background-color</span>: <span class="cn">#567895</span><span class="op">;</span></span><span id="cb9-3"><a href="#cb9-3"></a>}</span></code></pre></div><h2 id="背景图片">背景图片</h2><div class="sourceCode" id="cb10"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb10-1"><a href="#cb10-1"></a><span class="fu">.a</span> {</span><span id="cb10-2"><a href="#cb10-2"></a>  <span class="kw">background-image</span>: <span class="fu">url(</span><span class="st">balloons.jpg</span><span class="fu">)</span><span class="op">;</span></span><span id="cb10-3"><a href="#cb10-3"></a>}</span></code></pre></div><ul><li>此图片不会伸缩来适应大小，对于小图其会默认进行平铺，对于大图则只会显示其左上角。</li><li>如果背景图片和背景颜色同时设置，则图片会在颜色的上面。</li></ul><h3 id="背景图片平铺">背景图片平铺</h3><div class="sourceCode" id="cb11"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb11-1"><a href="#cb11-1"></a><span class="fu">.box</span> {</span><span id="cb11-2"><a href="#cb11-2"></a>  <span class="kw">background-image</span>: <span class="fu">url(</span><span class="st">star.png</span><span class="fu">)</span><span class="op">;</span></span><span id="cb11-3"><a href="#cb11-3"></a>  <span class="kw">background-repeat</span>: <span class="dv">no-repeat</span><span class="op">;</span></span><span id="cb11-4"><a href="#cb11-4"></a>}</span></code></pre></div><ul><li><code>no-repeat</code> — 不重复。</li><li><code>repeat-x</code> —水平重复。</li><li><code>repeat-y</code> —垂直重复。</li><li><code>repeat</code> — 在两个方向重复。</li></ul><h3 id="背景图片大小">背景图片大小</h3><div class="sourceCode" id="cb12"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb12-1"><a href="#cb12-1"></a><span class="fu">.box</span> {</span><span id="cb12-2"><a href="#cb12-2"></a>  <span class="kw">background-image</span>: <span class="fu">url(</span><span class="st">balloons.jpg</span><span class="fu">)</span><span class="op">;</span></span><span id="cb12-3"><a href="#cb12-3"></a>  <span class="kw">background-repeat</span>: <span class="dv">no-repeat</span><span class="op">;</span></span><span id="cb12-4"><a href="#cb12-4"></a>  <span class="kw">background-size</span>: <span class="dv">100</span><span class="dt">%</span><span class="op">;</span></span><span id="cb12-5"><a href="#cb12-5"></a>}</span></code></pre></div><p><code>bachground-size</code>的值可以是百分比、绝对的值，可以使用两个分别代表宽和高。</p><p>也可以使用下面的两个关键字：</p><ul><li><code>cover</code> — 浏览器将使图像足够大，使它完全覆盖了盒子区，同时仍然保持其高宽比。在这种情况下，有些图像可能会跳出盒子外</li><li><code>contain</code> — 浏览器将使图像的大小适合盒子内。在这种情况下，如果图像的长宽比与盒子的长宽比不同，则可能在图像的任何一边或顶部和底部出现间隙。</li></ul><h3 id="背景图像定位">背景图像定位</h3><div class="sourceCode" id="cb13"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb13-1"><a href="#cb13-1"></a><span class="fu">.box</span> { </span><span id="cb13-2"><a href="#cb13-2"></a>  <span class="kw">background-image</span>: <span class="fu">url(</span><span class="st">star.png</span><span class="fu">)</span><span class="op">;</span> </span><span id="cb13-3"><a href="#cb13-3"></a>  <span class="kw">background-repeat</span>: <span class="dv">no-repeat</span><span class="op">;</span> </span><span id="cb13-4"><a href="#cb13-4"></a>  <span class="kw">background-position</span>: <span class="dv">top</span> <span class="dv">center</span><span class="op">;</span> </span><span id="cb13-5"><a href="#cb13-5"></a>} </span></code></pre></div><p><code>background-position</code>除了可以使用<code>top</code>或<code>center</code>这样的关键字外，还可以使用长度或百分比。</p><p>第一个是水平值，第二个是垂直值。</p><h2 id="渐变背景">渐变背景</h2><p>这个实际上直接使用<code>background-image</code>来设置，只是值要放<code>linear-gradient</code>函数。</p><div class="sourceCode" id="cb14"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb14-1"><a href="#cb14-1"></a><span class="fu">.a</span> {</span><span id="cb14-2"><a href="#cb14-2"></a>  <span class="kw">background-image</span>: <span class="fu">linear-gradient(</span><span class="dv">105</span><span class="dt">deg</span><span class="op">,</span> rgba(<span class="dv">0</span><span class="op">,</span><span class="dv">249</span><span class="op">,</span><span class="dv">255</span><span class="op">,</span><span class="dv">1</span><span class="fu">)</span> <span class="dv">39</span><span class="dt">%</span><span class="op">,</span> <span class="fu">rgba(</span><span class="dv">51</span><span class="op">,</span><span class="dv">56</span><span class="op">,</span><span class="dv">57</span><span class="op">,</span><span class="dv">1</span><span class="fu">)</span> <span class="dv">96</span><span class="dt">%</span>)<span class="op">;</span></span><span id="cb14-3"><a href="#cb14-3"></a>}</span></code></pre></div><p>实际上这个值一般可以通过各种渐变生成器来得到我们想要的渐变色，比如<a href="https://cssgradient.io/" target="_blank" rel="noopener">这个</a>。</p><h2 id="多个背景图像">多个背景图像</h2><p>使用逗号进行分割即可。其他 <code>background-*</code>属性也可以有值逗号分隔的方式，与<code>background-image</code>相同。</p><blockquote><p>注意这些图像会被层层叠加在一起.<br>注意，渐变可以和常规的背景图像很好的混合在一起。</p></blockquote><div class="sourceCode" id="cb15"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb15-1"><a href="#cb15-1"></a>background-image<span class="in">: url(image1.png)</span><span class="op">,</span> url(image2<span class="fu">.png</span>)<span class="op">,</span> url(image3<span class="fu">.png</span>)<span class="op">,</span> url(image1<span class="fu">.png</span>);</span><span id="cb15-2"><a href="#cb15-2"></a>background-repeat<span class="in">: no-repeat</span><span class="op">,</span> repeat-x<span class="op">,</span> repeat;</span><span id="cb15-3"><a href="#cb15-3"></a>background-position<span class="in">: 10px 20px,  top</span> right;</span></code></pre></div><p>不同属性的每个值将与其他属性中相同位置的值匹配。例如，上面的<code>image1</code>的<code>background-repeat</code>值将是<code>no-repeat</code>。但是，当不同的属性具有不同数量的值时，会发生什么情况呢？答案是较小数量的值会循环—在上面的例子中有四个背景图像，但是只有两个背景位置值。前两个位置值将应用于前两个图像，然后它们将再次循环—image3将被赋予第一个位置值，image4将被赋予第二个位置值。</p><h2 id="背景附着">背景附着</h2><p>使用<code>background-attachment</code>，其有以下的值：</p><ul><li><code>scroll</code>: 使元素的背景在页面滚动时滚动。如果滚动了元素内容，则背景不会移动。实际上，背景被固定在页面的相同位置，所以它会随着页面的滚动而滚动。</li><li><code>fixed</code>: 使元素的背景固定在视图端口上，这样当页面或元素内容滚动时，它就不会滚动。它将始终保持在屏幕上相同的位置。</li><li><code>local</code>: 这个值是后来添加的(它只在Internet Explorer 9+中受支持，而其他的在IE4+中受支持)，因为滚动值相当混乱，在很多情况下并不能真正实现您想要的功能。局部值将背景固定在设置的元素上，因此当您滚动元素时，背景也随之滚动。</li></ul><h2 id="背景的缩写">背景的缩写</h2><p>最终，我们迎来了最开始的那个复杂的声明。</p><p>如果使用多个背景，则需要为第一个背景指定所有普通属性，然后在逗号后面添加下一个背景。在下面的例子中，我们有一个渐变，它指定大小和位置，然后是一个无重复的图像背景，它指定位置，然后是一个颜色。</p><p>这里有一些规则，需要在简写背景属性时遵循，例如:</p><ul><li><code>background-color</code> 只能在逗号之后指定。</li><li><code>background-size</code> 值只能包含在背景位置之后，用<code>'/'</code>字符分隔，例如：<code>center/80%</code>。</li></ul><h1 id="边框">边框</h1><p>边框的属性也可以直接用一个<code>border</code>来一起声明：</p><div class="sourceCode" id="cb16"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb16-1"><a href="#cb16-1"></a><span class="fu">.box</span> { </span><span id="cb16-2"><a href="#cb16-2"></a>  <span class="kw">border</span>: <span class="dv">1</span><span class="dt">px</span> <span class="dv">solid</span> <span class="cn">black</span><span class="op">;</span> </span><span id="cb16-3"><a href="#cb16-3"></a>} </span></code></pre></div><p>或者只设置一个边：</p><div class="sourceCode" id="cb17"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb17-1"><a href="#cb17-1"></a><span class="fu">.box</span> { </span><span id="cb17-2"><a href="#cb17-2"></a>  <span class="kw">border-top</span>: <span class="dv">1</span><span class="dt">px</span> <span class="dv">solid</span> <span class="cn">black</span><span class="op">;</span> </span><span id="cb17-3"><a href="#cb17-3"></a>} </span></code></pre></div><h2 id="圆角">圆角</h2><p>我们可以通过<code>border-radius</code>来将方框的直角变成圆角。</p><ol type="1"><li>可以使用一个值（px或百分比），这时产生的是标准的圆角；</li><li>也可以一次放2个不同的值，这时产生的是椭圆角；</li><li>我们也可以为每个角单独设置；</li><li>如果给的值够大，是可以画圆的（<code>50%</code>）；</li></ol><p>例：</p><div class="sourceCode" id="cb18"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb18-1"><a href="#cb18-1"></a><span class="fu">.box</span> { </span><span id="cb18-2"><a href="#cb18-2"></a>  <span class="kw">border-radius</span>: <span class="dv">10</span><span class="dt">px</span><span class="op">;</span> </span><span id="cb18-3"><a href="#cb18-3"></a>} </span><span id="cb18-4"><a href="#cb18-4"></a></span><span id="cb18-5"><a href="#cb18-5"></a><span class="fu">.box</span> { </span><span id="cb18-6"><a href="#cb18-6"></a>  <span class="kw">border-top-right-radius</span>: <span class="dv">1</span><span class="dt">em</span> <span class="dv">10</span><span class="dt">%</span><span class="op">;</span> </span><span id="cb18-7"><a href="#cb18-7"></a>} </span></code></pre></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MDN学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文精读-基于RNN的GRN-2016</title>
      <link href="/2020/05/17/rnn-jian-wang-2016/"/>
      <url>/2020/05/17/rnn-jian-wang-2016/</url>
      
        <content type="html"><![CDATA[<h1 id="recurrent-neural-network-based-hybrid-model-of-gene-regulatory-network">Recurrent Neural Network Based Hybrid Model of Gene Regulatory Network</h1><ul><li>杂志: Computational biology and chemistry</li><li>IF: 1.581</li><li>分区: 4区</li></ul><hr><h2 id="introduction">Introduction</h2><ol type="1"><li><p>建模生物网络的目的：</p><ul><li>网络的模式可以提供更好的、在整体上的、关于交互和关联的理解；</li><li>允许研究者对gene的功能进行预测并验证；</li><li>分子和细胞间交互作用的复杂性，使得我们也对这种能够设计和解释实验结果的建模工具有着巨大的需求；</li><li>对于理解细胞行为是关键的，可能会启发更好的治疗方法；</li><li>可以预测更多的未知的生物大分子；</li><li>可以为药效模拟提供依据。</li></ul></li><li><p>基因调控网络（gene regulatory networks, GRNs）</p><ul><li>包括了输入信号通路、接受输入信号的调控蛋白、靶基因、靶基因产生的RNA和蛋白质等。</li><li>可能还有动态的反馈调节。</li><li>使用graph的形式来表示，其中node是genes，edge是调控关系。是一个directed graph。</li></ul></li><li><p>本研究提出了一种hybrid方法，基于RNN，并整合了generalized extended Kalman filter。</p></li></ol><h2 id="建模grns的方法">建模GRNs的方法</h2><p><em>文章中列举了很多，这里就只把其分类说一下就好了</em></p><ul><li>Directed Graph</li><li>Boolean networks</li><li>Bayesian networks</li><li>linear and non-linear ordinary differential equations（ODEs）</li><li>machine Learning approaches</li></ul><p><em>之后介绍的大多数方法都是基于ML的了，而且大多数是基于NNs的了</em></p><ul><li>【Vohradsky, 2001】使用ANN来进行建模，但模型参数过多；</li><li>【Keedwell et al., 2002】简化了上述模型，并且使用标准的BP算法来进行学习；</li><li>【Tian &amp; Burrage, 2003】使用了随机神经网络来建模GRNs；</li><li>【Xu et al., 2004】则使用RNN来进行建模，使用BPTT和PSO（粒子群算法）来进行学习；</li><li>【Chiang &amp; Chao, 2007】将GA和RNN杂交（GA-RNN）去进行学习；</li><li>【Xu et al, 2007b】提出了PSO-RNN；</li><li>【Xu et al., 2007a】进一步去试验了另外的3种优化方法：DE、PSO、DE-PSO，发现DE-PSO和RNN的结合是最好的；</li><li>【Ghazikhani et al., 2011】提出了一个基于multi-population PSO算法的模型，在SOS repair network的构建中体现除了更好的效果；</li><li>【Noman et al., 2013】提出了decoupled-RNN model，decoupled意味着其将参数的估计分成几部分进行，从而提高了效率，使得对于大规模网络的建模称为可能；</li><li>【Raza et al., 2014】，这是作者的早期研究，使用了一种进化算法-ACO来找到genes间的关键交互。</li></ul><h2 id="methods">Methods</h2><h3 id="rnns">RNNs</h3><p><em>这一部分涉及RNNs基础的，就不再赘述了。</em></p><p><em>从后面对于模型的叙述并结合这一部分的RNNs的介绍，这里的RNNs并不是DL中的RNNs，而更像是前DL时代中的RNNs</em></p><h3 id="基于rnns的grns模型">基于RNNs的GRNs模型</h3><p>假设：特定基因上的调控效应可以表示为NN的形式，其中节点表示的是gene，链接表示的是调控关系。</p><p>根据【Rui et al., 2004; Hu et al., 2005; Noman et al., 2013; Raza, 2014】，GRNs的模型可以表示为以下的格式：</p><p><img src="/2020/05/17/rnn-jian-wang-2016/RNN建网2016_2020-05-17-12-05-19.png"><br></p><p>其中<span class="math inline">\(e_i\)</span>表示基因<span class="math inline">\(i\)</span>的表达水平，<span class="math inline">\(n\)</span>表示所有的genes的数量，<span class="math inline">\(f\)</span>是一个非线性函数，一般使用sigmoid（<span class="math inline">\(f(z)=1/(1+exp(-z))\)</span>），<span class="math inline">\(w_{ij}\)</span>表示gene <span class="math inline">\(j\)</span>对gene <span class="math inline">\(i\)</span>的调控权重。<span class="math inline">\(u_k\)</span>表示的是外部变量，<span class="math inline">\(v_{ik}\)</span>表示的是外部变量对gene <span class="math inline">\(i\)</span>的影响。<span class="math inline">\(\tau_i\)</span>是一个时间常数，<span class="math inline">\(\beta_i\)</span>是偏置项，<span class="math inline">\(\lambda_i\)</span>是衰减率参数。</p><p>我们可以知道，<span class="math inline">\(w_{ij}\lt0\)</span>表示gene <span class="math inline">\(j\)</span>对gene <span class="math inline">\(i\)</span>是抑制作用，而<span class="math inline">\(w_{ij}=0\)</span>表示gene <span class="math inline">\(j\)</span>对gene <span class="math inline">\(i\)</span>没有调控作用。</p><p>上面公式也可以写成下面的离散形式：</p><p><img src="/2020/05/17/rnn-jian-wang-2016/RNN建网2016_2020-05-17-12-14-07.png"><br></p><h3 id="使用bptt来训练">使用BPTT来训练</h3><p><img src="/2020/05/17/rnn-jian-wang-2016/RNN建网2016_2020-05-17-12-37-59.png"><br></p><h3 id="kalman-filter">Kalman filter</h3><p>关于卡尔曼滤波器的基本信息，可以查看<a href="https://zh.wikipedia.org/wiki/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2" target="_blank" rel="noopener">wiki</a>。</p><p><a href="https://zhuanlan.zhihu.com/p/39912633" target="_blank" rel="noopener">这里</a>是一个关于kalman filter的解释，可能更加容易理解。</p><blockquote><p>一个时间序列，我们已知一个时间点<span class="math inline">\(t\)</span>的最佳估计（当然这个估计也是随机的，有一个方差），我们有两种方式来得到下一个时间点<span class="math inline">\(t+1\)</span>的估计：</p><ul><li>根据时间点间的关系进行<strong>预测</strong>、</li><li>直接在下一个时间点进行测量或<strong>观测</strong>。</li></ul><p>但还有一个更好的方式，就是将这两种方式结合，此即<strong>卡尔曼滤波</strong>。</p><p>简单来说，就是通过计算<strong>预测</strong>和<strong>观测</strong>各自的方差，利用方差做权重来调整对下一个时间点的估计。如果利用贝叶斯的观点来说，<strong>预测</strong>得到的结果可以看做是下一个时间点的先验估计，而<strong>观测</strong>可以看做是样本，然后调整先验估计，得到后验估计。</p><p>在kalman filter的命名中，<strong>预测</strong>即predict，而<strong>观测</strong>进行调整的过程即correct。</p><p>如果上一个时间点的估计是精确的，即此时方差为0，则计算权重的时候将不会再为<strong>观测</strong>分配权重，则整个时间序列过程退化为一个确定性过程。</p><p>更加general的模型还会有一个外部环境影响因素，这个也是一个随机变量，则此时，就算是初始估计是精确地，因为此随机外部环境的影响，我们也无法忽略<strong>观测</strong>过程。</p><p>在本文的例子中，RNN所预测的权重被看做是一个<strong>预测</strong>。</p><p>对于本文用到的generalized extended kalman filter （GEKF），是更加general的清楚，将非线性的过程加入其中。****</p></blockquote><p><img src="/2020/05/17/rnn-jian-wang-2016/RNN建网2016_2020-05-17-14-36-38.png" alt="GEKF for RNNs"><br></p><p><em>如何把RNN的weight matrix应用到Kalman filter中进行处理，这一段没有看懂？？？</em></p><h3 id="工作流程">工作流程</h3><p><img src="/2020/05/17/rnn-jian-wang-2016/RNN建网2016_2020-05-17-12-15-20.png" alt="工作流"><br></p><ol type="1"><li>读取microarray数据（时间序列数据或者稳态数据），并进行预处理和标准化；</li><li>模型训练；</li><li>读取模型的weight matrix，将其离散化为0和1；</li><li>将离散化的matrix可视化；</li><li>和true network进行比对，对结果进行评价。</li></ol><h2 id="results-and-discussion">Results and Discussion</h2><p>本方法一共在4个数据集（2个real、2个simulated）上进行了验证和比较。</p><h3 id="sos-dna-repair-networks">SOS DNA repair networks</h3><p>使用proposed method得到weight matrix，然后应用Inter-Quartile离散化，得到结果如下：</p><p><img src="/2020/05/17/rnn-jian-wang-2016/RNN建网2016_2020-05-19-13-59-23.png" alt="在SOS-DNA修复网络评价"><br></p><p><img src="/2020/05/17/rnn-jian-wang-2016/RNN建网2016_2020-05-19-14-00-32.png" alt="在SOS-DNA修复网络上和其他方法的比较"><br></p><p><img src="/2020/05/17/rnn-jian-wang-2016/RNN建网2016_2020-05-19-14-01-18.png" alt="在SOS-DNA修复网络上和其他方法的比较2"><br></p><p><img src="/2020/05/17/rnn-jian-wang-2016/RNN建网2016_2020-05-19-14-04-33.png" alt="SOS-DNA修复网络基因表达量预测-uvrD"><br></p><p><img src="/2020/05/17/rnn-jian-wang-2016/RNN建网2016_2020-05-19-14-05-41.png" alt="SOS-DNA修复网络基因表达量预测-lexA"><br></p><p><img src="/2020/05/17/rnn-jian-wang-2016/RNN建网2016_2020-05-19-14-06-10.png" alt="SOS-DNA修复网络基因表达量预测-umuDC"><br></p><p><img src="/2020/05/17/rnn-jian-wang-2016/RNN建网2016_2020-05-19-14-06-42.png" alt="SOS-DNA修复网络基因表达量预测-recA"><br></p><p><img src="/2020/05/17/rnn-jian-wang-2016/RNN建网2016_2020-05-19-14-07-15.png" alt="SOS-DNA修复网络基因表达量预测-uvrA"><br></p><p><img src="/2020/05/17/rnn-jian-wang-2016/RNN建网2016_2020-05-19-14-07-40.png" alt="SOS-DNA修复网络基因表达量预测-ruvA"><br></p><p><img src="/2020/05/17/rnn-jian-wang-2016/RNN建网2016_2020-05-19-14-08-05.png" alt="SOS-DNA修复网络基因表达量预测-polB"><br></p><h3 id="in-vivo-reverse-engineering-and-assessment-yeast-network-irma">in-vivo reverse-engineering and assessment yeast network （IRMA）</h3><ol type="1"><li><p>switch OFF状态</p><p><img src="/2020/05/17/rnn-jian-wang-2016/RNN建网2016_2020-05-19-14-26-22.png"><br></p><p><img src="/2020/05/17/rnn-jian-wang-2016/RNN建网2016_2020-05-19-14-27-02.png"><br></p></li><li><p>swith ON状态</p><p><img src="/2020/05/17/rnn-jian-wang-2016/RNN建网2016_2020-05-19-14-27-29.png"><br></p><p><img src="/2020/05/17/rnn-jian-wang-2016/RNN建网2016_2020-05-19-14-27-45.png"><br></p></li></ol><h3 id="silico-networkssimulated-datadream4">silico networks（simulated data，DREAM4）</h3><ol type="1"><li><p>DREAM4 10-genes network：</p><p><img src="/2020/05/17/rnn-jian-wang-2016/RNN建网2016_2020-05-19-14-28-48.png"><br></p></li><li><p>DREAM3 50-genes network:</p><p>一共125条调控作用，预测到其中的121条，但有662条假阳性预测，得到了0.76的sensitivity和0.72的specificity。</p></li></ol><h3 id="模型的稳健性">模型的稳健性</h3><p>在silico 10-genes data上加了5% std的高斯噪声，发现proposed method还是能够得到不错的预测：</p><p><img src="/2020/05/17/rnn-jian-wang-2016/RNN建网2016_2020-05-19-14-32-20.png"><br></p><h2 id="conclusion">Conclusion</h2><p>本文提出了一种基于RNN的基因调控网络构建方法，其混合使用Kalman filter对weight matrix进行进一步的增强。在4个数据集上进行了验证，发现在前3个数据集上都能够超越之前的建网方法。另外，还进行了稳健性的验证，也得到了不错的结果。</p><p>基因调控网络的构建依然面临着诸多问题：维度灾难问题、数据的异质性（比如批次）噪声、不可靠数据等，有待进一步解决。</p><hr><h2 id="questions">Questions</h2><p><em>读过本文后才发现，本文并不是deep learning意义上的RNNs的应用，这里RNNs的定义还带有前DL时代的影子。这里的RNNs只是单层的，其应用的目的也只是为了解决一个普通的时间序列预测问题。</em></p><p><em>在我看来，本文的主要贡献是在于在RNNs之后又应用了kalman filter进行进一步的校正。这样的组合让我想起了我研究生期间研究的一种建网策略：即先利用建网方法进行网络建立，然后使用一些方法来删除其中的假阳性预测。我想这两者之间在策略、哲学上还是有共同之处的。</em></p><p><em>通过阅读本论文，我第一次、一定程度地了解了Kalman filte的知识，希望在之后的研究中有帮助吧。</em></p><p><em>但本研究对于RNN和filter的组合太过生硬了，而且实验使用的数据集gene的数量也不多，还没有到达组学的范畴。</em></p><p><em>本文所叙述的一些内容（使用的数据集，kalman filter等）我是第一次接触，所以读起来还是有些磕磕绊绊，results部分也是简单的浏览了一下表格和图，没有进行深入的理解。</em></p><p><em>下面的是我在阅读时产生的问题，权当是为了记录而记录，便于当之后的研究需要本文时有个快速回忆的锚点。</em></p><ol type="1"><li><em>在这个kalman filter过程中，什么充当了观测的角色？</em></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Paper </category>
          
          <category> Method </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Deep Learning </tag>
            
            <tag> Omics </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS选择器</title>
      <link href="/2020/05/16/css-xuan-ze-qi/"/>
      <url>/2020/05/16/css-xuan-ze-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="元素选择器">元素选择器</h1><p>例：</p><div class="sourceCode" id="cb1"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb1-1"><a href="#cb1-1"></a>span {</span><span id="cb1-2"><a href="#cb1-2"></a>    <span class="kw">background-color</span>: <span class="cn">yellow</span><span class="op">;</span></span><span id="cb1-3"><a href="#cb1-3"></a>}</span><span id="cb1-4"><a href="#cb1-4"></a></span><span id="cb1-5"><a href="#cb1-5"></a>strong {</span><span id="cb1-6"><a href="#cb1-6"></a>    <span class="kw">color</span>: <span class="cn">rebeccapurple</span><span class="op">;</span></span><span id="cb1-7"><a href="#cb1-7"></a>}</span><span id="cb1-8"><a href="#cb1-8"></a></span><span id="cb1-9"><a href="#cb1-9"></a>em {</span><span id="cb1-10"><a href="#cb1-10"></a>    <span class="kw">color</span>: <span class="cn">rebeccapurple</span><span class="op">;</span></span><span id="cb1-11"><a href="#cb1-11"></a>}</span></code></pre></div><h1 id="类选择器">类选择器</h1><p>例：</p><div class="sourceCode" id="cb2"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb2-1"><a href="#cb2-1"></a><span class="fu">.highlight</span> {</span><span id="cb2-2"><a href="#cb2-2"></a>    <span class="kw">background-color</span>: <span class="cn">yellow</span><span class="op">;</span></span><span id="cb2-3"><a href="#cb2-3"></a>}</span></code></pre></div><p>类选择器的优势在于灵活，可以通过给元素插入多个类实现更加节省的实现。</p><p><strong>注意插入多个类的时候是空格分隔的。</strong></p><h1 id="id选择器">ID选择器</h1><p>例：</p><div class="sourceCode" id="cb3"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb3-1"><a href="#cb3-1"></a><span class="pp">#one</span> {</span><span id="cb3-2"><a href="#cb3-2"></a>    <span class="kw">background-color</span>: <span class="cn">yellow</span><span class="op">;</span></span><span id="cb3-3"><a href="#cb3-3"></a>}</span></code></pre></div><p><strong>ID只能被一个元素拥有。</strong></p><h1 id="属性选择器">属性选择器</h1><h2 id="存否和值选择器">存否和值选择器</h2><p><img src="/2020/05/16/css-xuan-ze-qi/CSS选择器_2020-05-16-21-23-00.png" alt="存否和值选择器"><br></p><p>虽然属性选择器常常和元素选择器混合使用，但其是可以单独使用的。</p><p>例：</p><div class="sourceCode" id="cb4"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb4-1"><a href="#cb4-1"></a>li<span class="ex">[class]</span> {</span><span id="cb4-2"><a href="#cb4-2"></a>    <span class="kw">font-size</span>: <span class="dv">200</span><span class="dt">%</span><span class="op">;</span></span><span id="cb4-3"><a href="#cb4-3"></a>}</span><span id="cb4-4"><a href="#cb4-4"></a></span><span id="cb4-5"><a href="#cb4-5"></a><span class="ex">[class</span><span class="op">=</span><span class="st">"a"</span><span class="ex">]</span> {</span><span id="cb4-6"><a href="#cb4-6"></a>    <span class="kw">background-color</span>: <span class="cn">yellow</span><span class="op">;</span></span><span id="cb4-7"><a href="#cb4-7"></a>}</span><span id="cb4-8"><a href="#cb4-8"></a></span><span id="cb4-9"><a href="#cb4-9"></a>li<span class="ex">[class</span><span class="op">~=</span><span class="st">"a"</span><span class="ex">]</span> {</span><span id="cb4-10"><a href="#cb4-10"></a>    <span class="kw">color</span>: <span class="cn">red</span><span class="op">;</span></span><span id="cb4-11"><a href="#cb4-11"></a>}</span></code></pre></div><h2 id="子字符串匹配选择器">子字符串匹配选择器</h2><p><img src="/2020/05/16/css-xuan-ze-qi/CSS选择器_2020-05-16-21-27-52.png" alt="子字符串匹配选择器"><br></p><p>例：</p><div class="sourceCode" id="cb5"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb5-1"><a href="#cb5-1"></a>li<span class="ex">[class</span><span class="op">^=</span><span class="st">"a"</span><span class="ex">]</span> {</span><span id="cb5-2"><a href="#cb5-2"></a>    <span class="kw">font-size</span>: <span class="dv">200</span><span class="dt">%</span><span class="op">;</span></span><span id="cb5-3"><a href="#cb5-3"></a>}</span><span id="cb5-4"><a href="#cb5-4"></a></span><span id="cb5-5"><a href="#cb5-5"></a>li<span class="ex">[class</span><span class="op">$=</span><span class="st">"a"</span><span class="ex">]</span> {</span><span id="cb5-6"><a href="#cb5-6"></a>    <span class="kw">background-color</span>: <span class="cn">yellow</span><span class="op">;</span></span><span id="cb5-7"><a href="#cb5-7"></a>}</span><span id="cb5-8"><a href="#cb5-8"></a></span><span id="cb5-9"><a href="#cb5-9"></a>li<span class="ex">[class</span><span class="op">*=</span><span class="st">"a"</span><span class="ex">]</span> {</span><span id="cb5-10"><a href="#cb5-10"></a>    <span class="kw">color</span>: <span class="cn">red</span><span class="op">;</span></span><span id="cb5-11"><a href="#cb5-11"></a>}</span></code></pre></div><h2 id="大小写不敏感">大小写不敏感</h2><p>如果你想在大小写不敏感的情况下，匹配属性值的话，你可以在闭合括号之前，使用i值。这个标记告诉浏览器，要以大小写不敏感的方式匹配ASCII字符。没有了这个标记的话，值会按照文档语言对大小写的处理方式，进行匹配——HTML中是大小写敏感的。</p><p>例：</p><div class="sourceCode" id="cb6"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb6-1"><a href="#cb6-1"></a>li<span class="ex">[class</span><span class="op">^=</span><span class="st">"a" i</span><span class="ex">]</span> {</span><span id="cb6-2"><a href="#cb6-2"></a>    <span class="kw">color</span>: <span class="cn">red</span><span class="op">;</span></span><span id="cb6-3"><a href="#cb6-3"></a>}</span></code></pre></div><h1 id="伪类选择器">伪类选择器</h1><p>伪类是一个选择处于特定状态的元素的选择器，比如它们是这一类型的第一个元素的时候，或者是鼠标指针悬浮在上面的时候。它们表现得会像是你向你的文档的某个部分应用了一个类一样，帮你在你的标记文本中减少多余的类，让你的代码更灵活、更易于维护。</p><p>伪类就是开头为冒号的关键字：</p><div class="sourceCode" id="cb7"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb7-1"><a href="#cb7-1"></a><span class="in">:pseudo-class-name</span></span></code></pre></div><h2 id="简单伪类">简单伪类</h2><div class="sourceCode" id="cb8"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb8-1"><a href="#cb8-1"></a><span class="in">:first-child</span>  <span class="co">/* 第一个元素 */</span></span><span id="cb8-2"><a href="#cb8-2"></a></span><span id="cb8-3"><a href="#cb8-3"></a>article <span class="in">:first-child</span> <span class="co">/* article元素内的第一个元素 */</span></span><span id="cb8-4"><a href="#cb8-4"></a></span><span id="cb8-5"><a href="#cb8-5"></a>article p<span class="in">:first-child</span> <span class="co">/* article元素内的第一个p元素 */</span></span></code></pre></div><div class="sourceCode" id="cb9"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb9-1"><a href="#cb9-1"></a><span class="in">:only-child</span>  <span class="co">/* 没有任何兄弟元素的元素，等价于下面的形式 */</span></span><span id="cb9-2"><a href="#cb9-2"></a></span><span id="cb9-3"><a href="#cb9-3"></a><span class="in">:first-child:last-child</span>  <span class="co">/* 当然，因为后面这两个用到了更多的选择器，所以权重会大一些 */</span></span><span id="cb9-4"><a href="#cb9-4"></a></span><span id="cb9-5"><a href="#cb9-5"></a><span class="in">:nth-child(1):nth-last-child(1)</span></span></code></pre></div><div class="sourceCode" id="cb10"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb10-1"><a href="#cb10-1"></a><span class="in">:invalid</span> <span class="co">/* 表示任意内容未通过验证的 &lt;input&gt; 或其他 &lt;form&gt; 元素 . */</span></span><span id="cb10-2"><a href="#cb10-2"></a></span><span id="cb10-3"><a href="#cb10-3"></a><span class="co">/* 没有输入正确的值的input元素会被高亮 */</span></span><span id="cb10-4"><a href="#cb10-4"></a>input<span class="in">:invalid</span> {</span><span id="cb10-5"><a href="#cb10-5"></a>  <span class="kw">background-color</span>: <span class="cn">pink</span><span class="op">;</span></span><span id="cb10-6"><a href="#cb10-6"></a>}</span></code></pre></div><p>这个伪类对于突出显示用户的字段错误非常有用。</p><p>......</p><h2 id="用户行为伪类">用户行为伪类</h2><p>一些伪类只会在用户以某种方式和文档交互的时候应用。这些用户行为伪类，有时叫做动态伪类，表现得就像是一个类在用户和元素交互的时候加到了元素上一样。案例包括：</p><div class="sourceCode" id="cb11"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb11-1"><a href="#cb11-1"></a><span class="in">:hover</span>  <span class="co">/* 只会在用户将指针挪到元素上的时候才会激活，一般就是链接元素。 */</span></span></code></pre></div><div class="sourceCode" id="cb12"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb12-1"><a href="#cb12-1"></a><span class="in">:focus</span>  <span class="co">/* 只会在用户使用键盘控制，选定元素的时候激活。 */</span></span></code></pre></div><p>......</p><h1 id="伪元素选择器">伪元素选择器</h1><p>伪元素以类似方式表现，不过表现得是像你往标记文本中加入全新的HTML元素一样，而不是向现有的元素上应用类。伪元素开头为双冒号<code>::</code>。</p><div class="sourceCode" id="cb13"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb13-1"><a href="#cb13-1"></a><span class="in">::pseudo-element-name</span></span></code></pre></div><p>例：</p><div class="sourceCode" id="cb14"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb14-1"><a href="#cb14-1"></a><span class="in">::first-line</span> <span class="co">/* 选中第一行 */</span></span></code></pre></div><div class="sourceCode" id="cb15"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb15-1"><a href="#cb15-1"></a><span class="co">/* 让第一段的第一行加粗 */</span></span><span id="cb15-2"><a href="#cb15-2"></a>article p<span class="in">:first-child::first-line</span> {</span><span id="cb15-3"><a href="#cb15-3"></a>    <span class="kw">font-size</span>: <span class="dv">120</span><span class="dt">%</span><span class="op">;</span></span><span id="cb15-4"><a href="#cb15-4"></a>    <span class="kw">font-weight</span>: <span class="dv">bold</span><span class="op">;</span></span><span id="cb15-5"><a href="#cb15-5"></a>}</span></code></pre></div><p>关于伪元素选择器，还有一对有意思的是<code>::before</code>和<code>::after</code>，两者配合<code>content</code>属性可以做到使用CSS来加入内容：</p><div class="sourceCode" id="cb16"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb16-1"><a href="#cb16-1"></a><span class="fu">.box</span><span class="in">::before</span> {</span><span id="cb16-2"><a href="#cb16-2"></a>    <span class="kw">content</span>: <span class="st">"This should show before the other content."</span></span><span id="cb16-3"><a href="#cb16-3"></a>}   </span></code></pre></div><div class="sourceCode" id="cb17"><pre class="sourceCode html"><code class="sourceCode html"><span id="cb17-1"><a href="#cb17-1"></a><span class="kw">&lt;p</span><span class="ot"> class=</span><span class="st">"box"</span><span class="kw">&gt;</span>Content in the box in my HTML page.<span class="kw">&lt;/p&gt;</span></span></code></pre></div><p>将出现下面的结果： <img src="/2020/05/16/css-xuan-ze-qi/CSS选择器_2020-05-16-22-07-43.png" alt="before伪元素选择器示例"></p><p>从CSS插入文本字符串，我们并不会在Web浏览器上经常这么做，因为对于一些屏幕阅读器来说，文本是不可见的，而且对于未来别人的查找和编辑也不是很方便。</p><p>这些伪类的更推荐的用法是插入一个图标，例如下面的示例加入的一个小箭头，作为一个视觉性的提示，而且我们并不希望屏幕阅读器读出它。</p><p>还有就是在局部的时候使用：</p><div class="sourceCode" id="cb18"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb18-1"><a href="#cb18-1"></a><span class="fu">.box</span><span class="in">::before</span> {</span><span id="cb18-2"><a href="#cb18-2"></a>    <span class="kw">content</span>: <span class="st">""</span><span class="op">;</span></span><span id="cb18-3"><a href="#cb18-3"></a>    <span class="kw">display</span>: <span class="dv">block</span><span class="op">;</span></span><span id="cb18-4"><a href="#cb18-4"></a>    <span class="kw">width</span>: <span class="dv">100</span><span class="dt">px</span><span class="op">;</span></span><span id="cb18-5"><a href="#cb18-5"></a>    <span class="kw">height</span>: <span class="dv">100</span><span class="dt">px</span><span class="op">;</span></span><span id="cb18-6"><a href="#cb18-6"></a>    <span class="kw">background-color</span>: <span class="cn">rebeccapurple</span><span class="op">;</span></span><span id="cb18-7"><a href="#cb18-7"></a>    <span class="kw">border</span>: <span class="dv">1</span><span class="dt">px</span> <span class="dv">solid</span> <span class="cn">black</span><span class="op">;</span></span><span id="cb18-8"><a href="#cb18-8"></a>}  </span></code></pre></div><div class="sourceCode" id="cb19"><pre class="sourceCode html"><code class="sourceCode html"><span id="cb19-1"><a href="#cb19-1"></a><span class="kw">&lt;p</span><span class="ot"> class=</span><span class="st">"box"</span><span class="kw">&gt;</span>Content in the box in my HTML page.<span class="kw">&lt;/p&gt;</span></span></code></pre></div><p>将出现下面的结果： <img src="/2020/05/16/css-xuan-ze-qi/CSS选择器_2020-05-16-22-10-29.png" alt="before伪元素选择器示例2"></p><p>......</p><hr><p>伪类和伪元素有许多，这里链接到了<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Selectors/Pseudo-classes_and_pseudo-elements" target="_blank" rel="noopener">MDN相关教程的参考节</a>上，其列举出了所有的伪类和伪元素，以及它们的作用，另外还链接到其各自的详情页上。</p><h1 id="全局选择器">全局选择器</h1><p>例：</p><div class="sourceCode" id="cb20"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb20-1"><a href="#cb20-1"></a><span class="op">*</span> {</span><span id="cb20-2"><a href="#cb20-2"></a>    <span class="kw">margin</span>: <span class="dv">0</span><span class="op">;</span></span><span id="cb20-3"><a href="#cb20-3"></a>    <span class="kw">padding</span>: <span class="dv">0</span><span class="op">;</span></span><span id="cb20-4"><a href="#cb20-4"></a>}</span></code></pre></div><p>以上做法很流行，这样做的好处是会把原来很多代理用户样式表中的元素自带的一些边距、填充值变为0，方便我们之后进行重新的部署。</p><p>全局选择器的另一个用途是为了让选择器更加易读。比如下面的例子，我们想要选择所有<code>&lt;article&gt;</code>元素中的第一个，则可以将伪类选择器<code>:first-child</code>设置为其兄弟选择器实现，但这可能导致不好读：</p><div class="sourceCode" id="cb21"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb21-1"><a href="#cb21-1"></a>article <span class="in">:first-child</span> {</span><span id="cb21-2"><a href="#cb21-2"></a></span><span id="cb21-3"><a href="#cb21-3"></a>}</span></code></pre></div><p>我们可以加上全局选择器使之更加清楚：</p><div class="sourceCode" id="cb22"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb22-1"><a href="#cb22-1"></a>article <span class="op">*</span><span class="in">:first-child</span> { </span><span id="cb22-2"><a href="#cb22-2"></a></span><span id="cb22-3"><a href="#cb22-3"></a>} </span></code></pre></div><h1 id="运算符组合选择器">*运算符（组合选择器）</h1><h2 id="取交集">取交集</h2><p>即同时符合多个选择器标准的元素 ，直接将多个选择器连接在一起即可：</p><div class="sourceCode" id="cb23"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb23-1"><a href="#cb23-1"></a>p<span class="fu">.AA</span>   <span class="co">/* class是AA的元素 */</span></span><span id="cb23-2"><a href="#cb23-2"></a></span><span id="cb23-3"><a href="#cb23-3"></a>p<span class="ex">[class</span><span class="op">~=</span><span class="st">"a"</span><span class="ex">]</span>   <span class="co">/* 有一个类是a的p元素 */</span></span></code></pre></div><h2 id="后代选择器">后代选择器</h2><div class="sourceCode" id="cb24"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb24-1"><a href="#cb24-1"></a>body article p</span></code></pre></div><h2 id="子代选择器">子代选择器</h2><div class="sourceCode" id="cb25"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb25-1"><a href="#cb25-1"></a>article <span class="op">&gt;</span> p</span></code></pre></div><h2 id="邻接兄弟选择器">邻接兄弟选择器</h2><div class="sourceCode" id="cb26"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb26-1"><a href="#cb26-1"></a>p <span class="op">+</span> img <span class="co">/* 紧随在p之后的img标签 */</span></span></code></pre></div><h2 id="通用兄弟选择器">通用兄弟选择器</h2><div class="sourceCode" id="cb27"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb27-1"><a href="#cb27-1"></a>p <span class="op">~</span> img <span class="co">/* 和p是兄弟关系的img标签，不必与p相邻 */</span></span></code></pre></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MDN学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS层叠、优先级和继承</title>
      <link href="/2020/05/16/css-ceng-die-you-xian-ji-ji-cheng/"/>
      <url>/2020/05/16/css-ceng-die-you-xian-ji-ji-cheng/</url>
      
        <content type="html"><![CDATA[<p>总的来说，层叠机制要先与优先级算法，默认继承最弱，指定继承则被优先级算法包括。</p><h1 id="层叠">层叠</h1><p>层叠（cascading），是一个定义了如何合并来自多个源的属性值的算法。</p><p>相互冲突的声明将按以下顺序适用，后一种声明将覆盖前一种声明：</p><ol start="0" type="1"><li><p>默认继承。</p></li><li><p>用户代理样式表中的声明（例如，浏览器的默认样式，在没有设置其他样式时使用）。</p></li><li><p>用户样式表中的常规声明（由用户设置的自定义样式）。</p></li><li><p>作者样式表中的常规声明（这些是我们web开发人员设置的样式）。</p><blockquote><p>这里包括我们声明的继承行为：<code>xx: inherit/initial/unset</code>。</p></blockquote></li><li><p>作者样式表中的<code>!important</code>声明</p></li><li><p>用户样式表中的<code>!important</code> 声明</p></li></ol><h1 id="优先级">优先级</h1><p>优先级（Specificity）算法，对于来自一个源的属性值声明，计算该声明的权重，通过权重的大小来指导合并属性值。</p><ol type="1"><li><p>最强的权重：<code>!important</code></p><p>这个实际上是层叠性的表现，在上面有说到：</p><p>例：</p><div class="sourceCode" id="cb1"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb1-1"><a href="#cb1-1"></a><span class="fu">.better</span> {</span><span id="cb1-2"><a href="#cb1-2"></a>  <span class="kw">background-color</span>: <span class="cn">gray</span><span class="op">;</span></span><span id="cb1-3"><a href="#cb1-3"></a>  <span class="kw">border</span>: <span class="dv">none</span> <span class="at">!important</span><span class="op">;</span></span><span id="cb1-4"><a href="#cb1-4"></a>}</span></code></pre></div></li><li><p>然后是权重的计算：权重有4位数，各位数间没有进位，</p><ul><li>千位： 如果声明在 <code>style</code> 的属性（内联样式）则该位得一分。这样的声明没有选择器，所以它得分总是1000。</li><li>百位： 选择器中包含<code>id</code>选择器（<code>#xx</code>）则该位得一分。</li><li>十位： 选择器中包含类选择器（<code>.xx</code>）、属性选择器（<code>[attr]</code>）或者伪类（<code>xx:hover</code>）则该位得一分。</li><li>个位：选择器中包含元素（<code>xx</code>）、伪元素（<code>:before</code>）选择器则该位得一分。</li><li>通用选择器（<code>*</code>）的权重为0。</li></ul><p>通过运算符连接了多个选择器，则多个选择器的权重相加。</p><p>例子如下： <img src="/2020/05/16/css-ceng-die-you-xian-ji-ji-cheng/CSS层叠优先级继承_2020-05-16-18-14-14.png" alt="优先级算法的例子"></p></li><li><p>最后，如果规则权重相同时，看顺序，在后面的会覆盖掉前面的。</p></li></ol><h1 id="继承">继承</h1><p>有些样式默认可以继承自父元素，但有些不是。到底是不是默认继承，通过常识判断即可。</p><blockquote><p>继承是有传递性的，所以行为类似作用域的感觉。在某元素定义了可以继承的属性后，在该元素内部的后代元素都会被继承。</p></blockquote><p>当然，我们也可以控制继承：任何元素都可以接受下面的关于继承控制的3个值来接受控制。</p><p><em>以下内容部分来自于<a href="https://medium.com/@elad/understanding-the-initial-inherit-and-unset-css-keywords-2d70b7121695" target="_blank" rel="noopener">Elad Schechter的博客</a></em></p><blockquote><p>首先我们需要明确CSS属性的Basic styles的概念。</p><ol type="1"><li>每个CSS属性都有一个initial value，这个值和element无关，即每一个element中的<code>color</code>的initial value都是一样的（当时<code>black</code>），<strong>注意，浏览器默认呈现的其实并不是这个值</strong>；</li><li>我们还有一个User-Agent Browser Styles（浏览器样式表或用户代理样式表），这个和浏览器有关（即不同的浏览器可能是不同的，当然大多数还是一样的），<strong>我们编写的html代码在不进行CSS属性设置的时候呈现的就是这个样式</strong>。如果该样式表中没有设置，才会使用initial value。</li></ol></blockquote><blockquote><p>另外，通过可继承性，也可以把属性分成两类（这个分类和elements也没有关系）：</p><ol type="1"><li>inherited properties，这些属性会进行继承，<strong>所有可以影响文本的属性都有这个性质</strong>；</li><li>non-inherited properties，这些属性不会进行继承，<strong>所有不会被应用到文本上的属性都是非继承的属性</strong>。</li></ol></blockquote><ul><li><p><code>inherit</code>：浏览器会搜索该element的最近的父元素，然后使用该元素的该属性的值；如果该元素没有设置，则会继续往上找，找更高级别的父元素的设置；如果所有的父元素都没有设置该值，则会采用user-agent style；如果浏览器样式表也没有设置，则使用initial values。（不管这个属性是什么类型的。）</p></li><li><p><code>initial</code>：浏览器直接使用元素的initial value。注意，这时候容易造成困惑，因为不同元素的同一个属性在浏览器样式表中是不同的，而设置成<code>initial</code>会使用同一个值，比如即使是<code>div</code>的<code>display</code>，也会使用其initial value，即<code>inline</code>。（不管这个属性是什么类型的。）</p></li><li><p><code>unset</code>：对inherited属性使用<code>inherit</code>，对noninherited属性使用<code>initial</code>。</p><blockquote><p>这样的话，就会涉及到一个问题：<code>unset</code>存在的必要是什么？这需要结合下面的<code>all</code>属性来解释了。</p></blockquote></li></ul><p>例：</p><div class="sourceCode" id="cb2"><pre class="sourceCode html"><code class="sourceCode html"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">&lt;ul&gt;</span></span><span id="cb2-2"><a href="#cb2-2"></a>    <span class="kw">&lt;li&gt;</span>Default <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">"#"</span><span class="kw">&gt;</span>link<span class="kw">&lt;/a&gt;</span> color<span class="kw">&lt;/li&gt;</span></span><span id="cb2-3"><a href="#cb2-3"></a>    <span class="kw">&lt;li</span><span class="ot"> class=</span><span class="st">"my-class-1"</span><span class="kw">&gt;</span>Inherit the <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">"#"</span><span class="kw">&gt;</span>link<span class="kw">&lt;/a&gt;</span> color<span class="kw">&lt;/li&gt;</span></span><span id="cb2-4"><a href="#cb2-4"></a>    <span class="kw">&lt;li</span><span class="ot"> class=</span><span class="st">"my-class-2"</span><span class="kw">&gt;</span>Reset the <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">"#"</span><span class="kw">&gt;</span>link<span class="kw">&lt;/a&gt;</span> color<span class="kw">&lt;/li&gt;</span></span><span id="cb2-5"><a href="#cb2-5"></a>    <span class="kw">&lt;li</span><span class="ot"> class=</span><span class="st">"my-class-3"</span><span class="kw">&gt;</span>Unset the <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">"#"</span><span class="kw">&gt;</span>link<span class="kw">&lt;/a&gt;</span> color<span class="kw">&lt;/li&gt;</span></span><span id="cb2-6"><a href="#cb2-6"></a><span class="kw">&lt;/ul&gt;</span></span></code></pre></div><div class="sourceCode" id="cb3"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb3-1"><a href="#cb3-1"></a>body {</span><span id="cb3-2"><a href="#cb3-2"></a>    <span class="kw">color</span>: <span class="cn">green</span><span class="op">;</span></span><span id="cb3-3"><a href="#cb3-3"></a>}</span><span id="cb3-4"><a href="#cb3-4"></a>       </span><span id="cb3-5"><a href="#cb3-5"></a><span class="co">/* 第一个列表的结果需要结合层叠性进行分析，即默认继承被</span></span><span id="cb3-6"><a href="#cb3-6"></a><span class="co">浏览器的用户代理样式表覆盖 */</span></span><span id="cb3-7"><a href="#cb3-7"></a></span><span id="cb3-8"><a href="#cb3-8"></a><span class="co">/* 第二个列表项被设置了inherit，其沿DOM树朝root节点去寻找最近的父元素属性，</span></span><span id="cb3-9"><a href="#cb3-9"></a><span class="co">找到了其直接父元素就有一个color的设置，是绿色，则进行继承，变成了绿色 */</span></span><span id="cb3-10"><a href="#cb3-10"></a><span class="fu">.my-class-1</span> a {</span><span id="cb3-11"><a href="#cb3-11"></a>    <span class="kw">color</span>: <span class="bu">inherit</span><span class="op">;</span></span><span id="cb3-12"><a href="#cb3-12"></a>}</span><span id="cb3-13"><a href="#cb3-13"></a>          </span><span id="cb3-14"><a href="#cb3-14"></a><span class="co">/* 第三个列表项设置为initial，则直接使用initial value，不管什么元素，color</span></span><span id="cb3-15"><a href="#cb3-15"></a><span class="co">属性的initial value就是black，所以被设置为黑色 */</span> </span><span id="cb3-16"><a href="#cb3-16"></a><span class="fu">.my-class-2</span> a {</span><span id="cb3-17"><a href="#cb3-17"></a>    <span class="kw">color</span>: initial<span class="op">;</span></span><span id="cb3-18"><a href="#cb3-18"></a>}</span><span id="cb3-19"><a href="#cb3-19"></a> </span><span id="cb3-20"><a href="#cb3-20"></a><span class="co">/* 第四个列表项被设置为unset，color是一个inherited属性（不管它在哪个element）中，所以unset变成了inherit，得到了和第二个列表项相同的结果*/</span></span><span id="cb3-21"><a href="#cb3-21"></a><span class="fu">.my-class-3</span> a {</span><span id="cb3-22"><a href="#cb3-22"></a>    <span class="kw">color</span>: <span class="bu">unset</span><span class="op">;</span></span><span id="cb3-23"><a href="#cb3-23"></a>}</span></code></pre></div><p>会有如下效果：</p><p><img src="/2020/05/16/css-ceng-die-you-xian-ji-ji-cheng/CSS层叠优先级继承_2020-05-16-18-26-28.png" alt="继承示例"><br></p><p>在想要给某个子元素进行格式修改的时候，一个一个进行修改可能比较麻烦。所以有一个特殊的属性<code>all</code>，可以一次性为选择到的元素设置所有属性。当然，各种属性接受的值的格式不一样，但<code>inherit</code>、<code>initial</code>和<code>unset</code>是他们都共同接受的。所以<code>all</code>属性最常接受的值就是这三个值。</p><blockquote><p>这里可以接受<code>unset</code>存在的意义了。如果只有<code>initial</code>和<code>inherit</code>，则我们在使用<code>all</code>的时候就比较分门别类地进行设置。比如我们希望设置所有的inherited属性为<code>inherit</code>，而noninherited属性为<code>initial</code>（经常会出现这种要求，毕竟哪些属性是inherited也不是随便定义的），这时候直接使用<code>all: unset</code>即可完成设置，显然方便了很多。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MDN学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文精读-深度学习组学应用-2018综述</title>
      <link href="/2020/05/15/dl-in-omics2019/"/>
      <url>/2020/05/15/dl-in-omics2019/</url>
      
        <content type="html"><![CDATA[<h1 id="deep-learning-in-omics-a-survey-and-guideline">Deep learning in omics: a survey and guideline</h1><ul><li>杂志: Briefings in functional genomics</li><li>IF: 3.133</li><li>分区: 2区</li></ul><hr><h2 id="introduction">Introduction</h2><ol type="1"><li><p>1943年MCP原型首次提出【1】--&gt; Rosenblatt提出感知机模型【2】--&gt; 1974年首次提出了back propagation（bp，反向传播算法）【3】--&gt; 2006年Hinton首次解决了梯度消失问题并显示了DL技术的重大潜力【4】。之后，因为：</p><ul><li>数据量大，数据维度高且复杂使得传统Machine Learning（ML）方法变得吃力；</li><li>硬件发展使得计算能力达到要求；</li><li>DL社区，特别是想Google的大公司推动了DL技术的发展；</li></ul><p>DL得到了空前的发展。其中也包括一系列bioinformatics领域的应用：</p><ul><li>利用电子病历数据进行疾病预测【5,6】；</li><li>生物医学图像分类【7-10】；</li><li>生物信号处理【11-13】；</li></ul></li><li><p>现代omics研究面临两个难题：</p><ul><li>在诊断、预测等应用领域，实验室方法昂贵且费时；</li><li>现存数据复杂、多态，传统方法已经难以处理；</li></ul><p>但这些难题都有望被深度学习克服。</p></li></ol><p><img src="/2020/05/15/dl-in-omics2019/DL-in-omics2019_2020-05-15-16-51-26.png" alt="深度学习及其在omics上的应用的文章数量变化"><br></p><h2 id="dl-models-in-omics">DL Models in Omics</h2><blockquote><p>这里涉及到很多基础的DL知识的，就不赘述了。</p></blockquote><h3 id="deep-neural-networks-dnns">Deep neural networks （DNNs）</h3><p>这里指代了MLP、AEs、RBMs和DBNs【4】等多种模型。其中DBNs解决了蛋白质残基连接预测【27】和RNA结合蛋白位点预测问题【28】。</p><h3 id="convolution-neural-networks-cnns">Convolution neural networks （CNNs）</h3><p>略。</p><h3 id="recurrent-neural-networks-rnns">Recurrent neural networks （RNNs）</h3><p>略。</p><h2 id="applications-in-omics">Applications in omics</h2><p>分为以下3个领域来介绍:</p><h3 id="genomics">Genomics</h3><ol type="1"><li><p>预测DNA序列的功能单元，如复制域（replication domain）、转录因子结合位点（transcription factor binding sites, TFBS）、转录起始点、启动子、增强子、基因删除位点等。</p><blockquote><ul><li>复制域：DNA复制时间调控的单位。<br></li><li><a href="https://zh.wikipedia.org/wiki/%E8%BD%AC%E5%BD%95%E5%9B%A0%E5%AD%90" target="_blank" rel="noopener">转录因子</a>：指能够结合在某基因上游特异核苷酸序列上的蛋白质，这些蛋白质能调控其基因的转录。方法是转录因子可以调控核糖核酸聚合酶（RNA聚合酶，或叫RNA合成酶）与DNA模板的结合。<br></li><li><a href="https://zh.wikipedia.org/wiki/%E5%95%9F%E5%8B%95%E5%AD%90" target="_blank" rel="noopener">启动子</a>：指一段能使特定基因进行转录的脱氧核糖核酸（DNA）序列。启动子可以被RNA聚合酶辨认，并开始转录合成RNA。在核糖核酸（RNA）合成中，启动子可以和调控基因转录的转录因子产生相互作用，控制基因表达（转录）的起始时间和表达的程度，包含核心启动子区域和调控区域，就像“开关”，决定基因的活动，继而控制细胞开始生产哪一种蛋白质。<br></li><li><a href="https://zh.wikipedia.org/wiki/%E5%BC%B7%E5%8C%96%E5%AD%90" target="_blank" rel="noopener">增强子</a>：是DNA上一小段可与蛋白质（反式作用因子；transacting factor，也就是转录因子）结合的区域，与蛋白质结合之后，基因的转录作用将会加强。增强子可能位于基因上游，也可能位于下游。且不一定接近所要作用的基因，甚至不一定与基因位于同一染色体。这是因为染色质的缠绕结构，使序列上相隔很远的位置也有机会相互接触。</li></ul></blockquote><ol type="a"><li>2015年，将预训练、DNN和hidden Markov model结合的模型实现了对复制域分类的突破【34】；</li><li>2016年，【35】通过使用convolutional/highway的MLP框架，依据TFBS来对基因序列进行分类，AUC达到了0.946；</li><li>【36】使用CNN模型来对启动子进行分子，实现了0.9左右的ACC；</li><li>【37】使用3层全连接来进行增强子和启动子的分类，达到了93.59的ACC；</li><li>【38】开发了一个浅层CNN模型-CNNdel，来进行基因删除位点的预测，使用来自1000 Genomes Projects的数据进行训练，也得到了超过其他方法的结果。</li></ol><p>总体来说，CNNs逐渐压过了DNNs称为主流，并且开始出现了CNNs+LSTMs的杂交模型。</p></li><li><p>预测基因表达。比如目标基因的表达量、预测基因功能、建模基因调控网络等。</p><ol type="a"><li>【39】利用GEO的microarray数据，训练了一个DNN model来预测目标基因的表达量，明显好于Logistic；</li><li>【40】基于stAEs和MLP，通过基因变异的基因型来预测基因表达；</li><li>【41】提出了一个基于CNN-biLSTM的模型，称为DanQ，来预测非编码区域的功能，实现了97.6的AUPR；</li><li>【42】使用RNN来建立基因调控网络，超越了其他的方法；</li></ol><p>CNNs依然是此领域的主要模型，而在研究比较少的基因调控网络领域，还是主要以RNN为主。</p></li><li><p>探索基因和疾病的关系。</p><ol type="a"><li>2017年，【43】使用MLP模型来预测cancer risk和生存，使用的是TCGA的数据，并和cox弹性网得到了类似的表现；</li><li>【44】使用CNNs来预测序列变异对近端CpG位点（DNA甲基化）的影响，得到了0.854的AUC；</li><li>【45】，即DeepCpG，在单细胞领域来预测甲基化位点，其使用的是CNN-RNN的杂交模型，并且模型可以解释；</li></ol><p>在预测甲基化的领域，还是以CNNs为主，RNNs可能会有所应用，但一般也要CNNs配合。而在探索基因和疾病的关系领域，主要使用DNNs，并且AEs和DBN也有所应用。</p></li></ol><h3 id="transcriptomics">Transcriptomics</h3><ol type="1"><li><p>预测RNA序列的结构，比如预测RBP结合位点、可变剪切位点和RNA类型。</p><ol type="a"><li>2015，基于DBN模型即可探索潜在的结合位点【28】，使用到的数据有RNA序列信息、RNA二级结构和RNA三级结构信息，相对于之前的方法MRE下降了22%；</li><li>【84】开发了一个deep CNNs model来进行剪切点的分类，称为DeeSpline，提高了预测ACC；</li><li>2017年，基于MLP的模型的成功实现了pre-miRNAs和psudo hair-pins的分类，并得到了0.968的ACC【46】；</li></ol></li><li><p>探索RNA和疾病的关联。</p><ol type="a"><li>2017年，基于DBN的一个分类模型，成功利用miRNA属性进行疾病的分类，平均提高了6%-10%【47】；</li><li>【48】使用转录组数据并结合DNN模型，来确定各种药物在不同生物系统下的药理学性质，此模型的效果要好于SVM；</li></ol></li></ol><h3 id="proteomics">Proteomics</h3><ol type="1"><li><p>蛋白质结构预测。比如蛋白质二级结构预测、蛋白质模型质量评估、protein contact map等。</p><ol type="a"><li>【49】通过st-sp AEs来预测二级结构和扭转角，使用原始氨基酸序列作为输入，达到了82%的ACC；</li><li>【36】使用DNN替代SVM来进行蛋白质模型质量评价，就PCC从0.85提高到了0.9；</li><li>【50】结合了两个deep residual networks来预测contacts，其接受sequence conservation information和evoluationary coupling作为输入，得到了最高的F1-score；</li></ol></li><li><p>蛋白质功能预测。</p><ol type="a"><li>【51】中，使用CNN模型来预测蛋白质功能，使用蛋白质三级结构作为输入，得到了87.6%的准确率；</li><li>【52】使用LSTM来预测4种类型蛋白质的功能，使用的是原始氨基酸序列作为输入，得到了99%的ACC；</li></ol></li><li><p>预测蛋白质交互作用、蛋白质亚细胞定位或其他功能。</p><ol type="a"><li>【53】使用stAEs来预测蛋白质交互作用，得到97.19%的ACC；</li><li>【54】使用CNNs模型来自动检测亚细胞定位，在每个细胞定位分类任务中得到了91%的ACC，在每个蛋白质上得到了99%的ACC；</li></ol></li></ol><h3 id="开源软件">开源软件</h3><p>很多人将开发的模型、工具的开源代码放在了网上，或者做成了web服务，现在将其列举如下： <img src="/2020/05/15/dl-in-omics2019/DL-in-omics2019_2020-05-15-18-32-19.png" alt="各种开源工具和代码"></p><h2 id="使用dl来解决omics问题">使用DL来解决omics问题</h2><p>这里总结了使用DL来进行omics研究的流程。</p><h3 id="数据获得">数据获得</h3><p>以下是常用的omics数据库：</p><p><img src="/2020/05/15/dl-in-omics2019/DL-in-omics2019_2020-05-15-18-40-03.png" alt="常用组学数据库"><br></p><p>需要对其进行一定的处理。</p><h3 id="数据预处理">数据预处理</h3><ol type="1"><li><p>data cleaning。</p><ul><li>缺失值填补，异常值处理：可使用k近邻、regression或决策树等方法来进行填补；</li><li>去除重复的数据：把相似性超过某个阈值的样本删除；</li><li>处理噪声：使用聚类方法、regression或binning；</li></ul><p>这个工作是time-consuming和labor-intensive，也没有什么统一的标准。可以使用一些方便的软件包：<code>OpenRefine</code>【124】或<code>DataKleenr</code>。</p></li><li><p>Normalization。</p><p>主要的作用是将数据缩放至一个合适的范围内。</p><ul><li>如果我们的数据比较集中，并且不服从正态分布，没有涉及到距离、相关性的计算，我们可以使用<strong>min-max normalization</strong>。比如图像数据。</li><li>如果数据大约服从正态分布，并且我们希望保留样本间距离关系，则可以使用<strong>zero-mean normalization</strong>。比如基因表达谱数据等。这也是最常用的normalization方法。</li></ul></li><li><p>Dimensionality reduction。</p><p>删除一些无关的变量，使用AEs来进行降维，或者使用PCA等等。</p></li></ol><h3 id="编码">编码</h3><dl><dt><strong>one-hot encoding</strong></dt><dd>略。</dd><dt><strong><a href="https://en.wikipedia.org/wiki/Position-Specific_Scoring_Matrix" target="_blank" rel="noopener">position-specific scoring matrix（PSSM, PWM, PSWM）</a></strong></dt><dd><p>也可以用来编码核苷酸序列或蛋白质序列，这里使用wiki的例子进行解释：</p><ol type="a"><li><p>我们有以下9条序列：</p><pre><code>GAGGTAAACTCCGTAAGTCAGGTTGGAACAGTCAGTTAGGTCATTTAGGTACTGATGGTAACTCAGGTATACTGTGTGAGTAAGGTAAGT</code></pre></li><li><p>首先将每个位置上的频数进行计算，称为PFM（position frequency matrix）： <img src="/2020/05/15/dl-in-omics2019/DL-in-omics2019_2020-05-15-22-07-33.png" alt="PFM"></p></li><li><p>然后每个位置归一化为概率，得到PPM（position probability matrix）： <img src="/2020/05/15/dl-in-omics2019/DL-in-omics2019_2020-05-15-22-09-13.png" alt="PPM"></p></li><li><p>最后将概率转换为权重，即使用<span class="math inline">\(log_2(M_{k,j}/b_k)\)</span>，其中<span class="math inline">\(b_k=1/|k|\)</span>，其中<span class="math inline">\(k\)</span>表示每个位置上的离散值有多少个，对于氨基酸序列<span class="math inline">\(k=20\)</span>，而对于核苷酸序列则<span class="math inline">\(k=4\)</span>，最后得到PWM（position weight matrix）： <img src="/2020/05/15/dl-in-omics2019/DL-in-omics2019_2020-05-15-22-13-04.png" alt="PWM"></p></li><li><p>然后使用其来编码数据即可。</p></li></ol><p>有一些现有的程序可以实现（比如PSI-BLAST），在这些算法中，其计算过程更加复杂，但基本思想是一致的。</p></dd></dl><p><strong><a href="https://en.wikipedia.org/wiki/Point_accepted_mutation" target="_blank" rel="noopener">PAM（point accepted mutation）matrix</a> and <a href="https://en.wikipedia.org/wiki/BLOSUM" target="_blank" rel="noopener">BLOSUM（blocks substitution）matrix</a></strong></p><p>除了以上3种方法外，对于蛋白质序列，还有autocovariance method和conjoint triad method 【126】方法。</p><p>另外，还有一些方法致力于将多种类型的数据进行整合分析【128,49,50,98,129】。</p><h3 id="模型选择">模型选择</h3><ol type="1"><li>尽量针对不同的任务使用不同的架构；</li><li>可以将多种不同的架构进行结合，从而得到更好的结果；</li><li>时刻关注最先进模型的研究，关于新技术。</li></ol><h3 id="模型训练">模型训练</h3><ol type="1"><li>考虑一下硬件配置是否支持；</li><li>注意数据集要分成training、validation和testing，本研究作者常用的分发为70%用作training和validation，30%用作testing；</li><li>合理选择激活函数，本研究作者建议的隐藏层激活函数为ReLU和maxout；</li><li>考虑试验一下dropout、early stop和weight decay，来预防过拟合。</li></ol><h3 id="评价">评价</h3><p>推荐使用交叉验证。</p><h3 id="深度学习框架">深度学习框架</h3><blockquote><p>这里总结了一下框架，但内容有点过时，就不贴了。</p></blockquote><h2 id="机会和挑战">机会和挑战</h2><ul><li><p>数据量：omics数据量一般不足，并且有imbalance的问题；</p><p>解决数据量不足：zero-shot learning【135】、one-shot learning【136】和GAN【137】； 解决imbalance：resamling、cost-sensitive learning【138】。</p></li><li><p>数据质量：omics数据一般来自不同平台，数据质量比较难以保证；</p><p>解决：上面提到的数据清洗过程。</p></li><li><p>计算花销：有硬件门槛；</p></li><li><p>“黑盒”问题：无法进行解释；</p><p>关于“黑盒”问题，也有所进展。比如【139】提出的Deep Motif Dashboard，就为TFBS的分类提供了一种可视化策略。</p></li><li><p>模型选择和训练：选择一个合适的模型和合适的超参数是困难的；</p></li></ul><p>当然，未来，还有一些其他的DL概念会对omics的研究产生影响：</p><ul><li>reinforcement leanring 【140】</li><li>incremental learning 【141】</li><li>transfer learning 【142】</li></ul><h2 id="结论">结论</h2><p>DL技术非常适合解决omics的问题。</p><hr><h2 id="questions">Questions</h2><p><em>这篇文章的一些结论或者内容感觉有些老了，之前以为是19年的文章，可能会比较新。但读到才发现可能是18年的。</em></p><p><em>但还是有所收获，特别是其介绍的一些序列编码方法是第一次听说。总结了一些文章的github。另外，其提到的文章中也有一些值得关注的。比如那个使用RNN来建网的方法，还有提到的一系列基于DBN的方法。</em></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Paper </category>
          
          <category> Review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Deep Learning </tag>
            
            <tag> Omics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS基础</title>
      <link href="/2020/05/15/css-ji-chu/"/>
      <url>/2020/05/15/css-ji-chu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Reference" target="_blank" rel="noopener">MDN CSS reference</a>列举了所有的CSS属性页面，可以作为文档查阅。</p><p>CSS中的注释：<code>/* ... */</code></p><h1 id="引用css的3种方式">引用CSS的3种方式</h1><ol type="1"><li><p>引用css文件：</p><div class="sourceCode" id="cb1"><pre class="sourceCode html"><code class="sourceCode html"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">&lt;link</span><span class="ot"> rel=</span><span class="st">"stylesheet"</span><span class="ot"> href=</span><span class="st">"style.css"</span><span class="kw">&gt;</span></span></code></pre></div></li><li><p>使用<code>head</code>中的<code>style</code>标签；</p></li><li><p>内联式，<code>&lt;p style="color: red; font-size: 10px;"&gt;</code>；</p></li></ol><h1 id="函数">函数</h1><div class="sourceCode" id="cb2"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb2-1"><a href="#cb2-1"></a><span class="fu">.box</span> {</span><span id="cb2-2"><a href="#cb2-2"></a>  <span class="kw">padding</span>: <span class="dv">10</span><span class="dt">px</span><span class="op">;</span></span><span id="cb2-3"><a href="#cb2-3"></a>  <span class="kw">width</span>: <span class="fu">calc(</span><span class="dv">90</span><span class="dt">%</span> <span class="op">-</span> <span class="dv">30</span><span class="dt">px</span><span class="fu">)</span><span class="op">;</span></span><span id="cb2-4"><a href="#cb2-4"></a>  <span class="kw">background-color</span>: <span class="cn">rebeccapurple</span><span class="op">;</span></span><span id="cb2-5"><a href="#cb2-5"></a>  <span class="kw">color</span>: <span class="cn">white</span><span class="op">;</span></span><span id="cb2-6"><a href="#cb2-6"></a>}</span></code></pre></div><h1 id="规则">规则</h1><div class="sourceCode" id="cb3"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb3-1"><a href="#cb3-1"></a>body {</span><span id="cb3-2"><a href="#cb3-2"></a>  <span class="kw">background-color</span>: <span class="cn">pink</span><span class="op">;</span></span><span id="cb3-3"><a href="#cb3-3"></a>}</span><span id="cb3-4"><a href="#cb3-4"></a></span><span id="cb3-5"><a href="#cb3-5"></a><span class="im">@media</span> (<span class="kw">min-width</span>: <span class="dv">30</span><span class="dt">em</span>) {</span><span id="cb3-6"><a href="#cb3-6"></a>  body {</span><span id="cb3-7"><a href="#cb3-7"></a>    <span class="kw">background-color</span>: <span class="cn">blue</span><span class="op">;</span></span><span id="cb3-8"><a href="#cb3-8"></a>  }</span><span id="cb3-9"><a href="#cb3-9"></a>}</span></code></pre></div><h1 id="css的工作流程">CSS的工作流程</h1><p>这里将CSS的工作原理，这种偏理论性质的东西放在最后面。</p><p><img src="/2020/05/15/css-ji-chu/CSS基础_2020-05-15-12-56-14.png" alt="CSS工作原理"><br></p><ol type="1"><li>浏览器载入HTML文件（比如从网络上获取）。</li><li>将HTML文件转化成一个DOM（Document Object Model），DOM是文件在计算机内存中的表现形式，下一节将更加详细的解释DOM。</li><li>接下来，浏览器会拉取该HTML相关的大部分资源，比如嵌入到页面的图片、视频和CSS样式。JavaScript则会稍后进行处理，简单起见，同时此节主讲CSS，所以这里对如何加载JavaScript不会展开叙述。</li><li>浏览器拉取到CSS之后会进行解析，根据选择器的不同类型（比如element、class、id等等）把他们分到不同的“桶”中。浏览器基于它找到的不同的选择器，将不同的规则（基于选择器的规则，如元素选择器、类选择器、id选择器等）应用在对应的DOM的节点中，并添加节点依赖的样式（这个中间步骤称为渲染树）。</li><li>上述的规则应用于渲染树之后，渲染树会依照应该出现的结构进行布局。</li><li>网页展示在屏幕上（这一步被称为着色）。</li></ol><h2 id="dom">DOM</h2><p>一个DOM有一个树形结构，标记语言中的每一个元素、属性以及每一段文字都对应着结构树中的一个节点（Node/DOM或DOM node）。节点由节点本身和其他DOM节点的关系定义，有些节点有父节点，有些节点有兄弟节点（同级节点）。</p><p>其将下面的代码解析成下面的树形结构：</p><div class="sourceCode" id="cb4"><pre class="sourceCode html"><code class="sourceCode html"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">&lt;p&gt;</span></span><span id="cb4-2"><a href="#cb4-2"></a>  Let's use:</span><span id="cb4-3"><a href="#cb4-3"></a>  <span class="kw">&lt;span&gt;</span>Cascading<span class="kw">&lt;/span&gt;</span></span><span id="cb4-4"><a href="#cb4-4"></a>  <span class="kw">&lt;span&gt;</span>Style<span class="kw">&lt;/span&gt;</span></span><span id="cb4-5"><a href="#cb4-5"></a>  <span class="kw">&lt;span&gt;</span>Sheets<span class="kw">&lt;/span&gt;</span></span><span id="cb4-6"><a href="#cb4-6"></a><span class="kw">&lt;/p&gt;</span></span></code></pre></div><pre><code>P├─ "Let's use:"├─ SPAN|  └─ "Cascading"├─ SPAN|  └─ "Style"└─ SPAN   └─ "Sheets"</code></pre><p>解析完成后，CSS会将样式逐一应用于DOM节点。</p><h2 id="当出现错误">当出现错误</h2><p>当出现错误时，浏览器会忽略掉整个选择器的设置，调到下一个选择器。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MDN学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML表格</title>
      <link href="/2020/05/14/html-biao-ge/"/>
      <url>/2020/05/14/html-biao-ge/</url>
      
        <content type="html"><![CDATA[<p>主要使用到的标签：<code>table</code>、<code>tr</code>、<code>th</code>、<code>td</code></p><p>使用表格进行布局的坏处：</p><ol type="1"><li>减少了视觉受损用户的可访问性；</li><li>表格会产生很多标签；</li><li>表格不能自动响应（使用正确的语义块级标签或<code>&lt;div&gt;</code>其默认宽度是父元素的100%，而表格不是），所以我们需要更多的操作来进行更改；</li></ol><h1 id="合并单元格">合并单元格</h1><p><code>th</code>和<code>td</code>标签有<code>colspan</code>和<code>rowspan</code>属性来控制。</p><h1 id="为表格的列提供共同的样式">为表格的列提供共同的样式</h1><p>使用<code>colgroup</code>和<code>col</code>标签进行如下定义：</p><div class="sourceCode" id="cb1"><pre class="sourceCode html"><code class="sourceCode html"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">&lt;table&gt;</span></span><span id="cb1-2"><a href="#cb1-2"></a>  <span class="kw">&lt;colgroup&gt;</span></span><span id="cb1-3"><a href="#cb1-3"></a>    <span class="kw">&lt;col&gt;</span></span><span id="cb1-4"><a href="#cb1-4"></a>    <span class="kw">&lt;col</span><span class="ot"> style=</span><span class="st">"background-color: yellow"</span><span class="kw">&gt;</span></span><span id="cb1-5"><a href="#cb1-5"></a>  <span class="kw">&lt;/colgroup&gt;</span></span><span id="cb1-6"><a href="#cb1-6"></a>  <span class="kw">&lt;tr&gt;</span></span><span id="cb1-7"><a href="#cb1-7"></a>    <span class="kw">&lt;th&gt;</span>Data 1<span class="kw">&lt;/th&gt;</span></span><span id="cb1-8"><a href="#cb1-8"></a>    <span class="kw">&lt;th&gt;</span>Data 2<span class="kw">&lt;/th&gt;</span></span><span id="cb1-9"><a href="#cb1-9"></a>  <span class="kw">&lt;/tr&gt;</span></span><span id="cb1-10"><a href="#cb1-10"></a>  <span class="kw">&lt;tr&gt;</span></span><span id="cb1-11"><a href="#cb1-11"></a>    <span class="kw">&lt;td&gt;</span>Calcutta<span class="kw">&lt;/td&gt;</span></span><span id="cb1-12"><a href="#cb1-12"></a>    <span class="kw">&lt;td&gt;</span>Orange<span class="kw">&lt;/td&gt;</span></span><span id="cb1-13"><a href="#cb1-13"></a>  <span class="kw">&lt;/tr&gt;</span></span><span id="cb1-14"><a href="#cb1-14"></a>  <span class="kw">&lt;tr&gt;</span></span><span id="cb1-15"><a href="#cb1-15"></a>    <span class="kw">&lt;td&gt;</span>Robots<span class="kw">&lt;/td&gt;</span></span><span id="cb1-16"><a href="#cb1-16"></a>    <span class="kw">&lt;td&gt;</span>Jazz<span class="kw">&lt;/td&gt;</span></span><span id="cb1-17"><a href="#cb1-17"></a>  <span class="kw">&lt;/tr&gt;</span></span><span id="cb1-18"><a href="#cb1-18"></a><span class="kw">&lt;/table&gt;</span></span></code></pre></div><table><colgroup><col><col style="background-color: yellow"></colgroup><tbody><tr><th>Data 1</th><th>Data 2</th></tr><tr><td>Calcutta</td><td>Orange</td></tr><tr><td>Robots</td><td>Jazz</td></tr></tbody></table><ul><li>有多少列，就写多少个<code>col</code></li><li>想要改变格式的列，在其对应的<code>col</code>元素中加入样式；</li><li>如果想要一次定义多列，使用<code>span</code>属性；</li></ul><div class="sourceCode" id="cb2"><pre class="sourceCode html"><code class="sourceCode html"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">&lt;colgroup&gt;</span></span><span id="cb2-2"><a href="#cb2-2"></a>  <span class="kw">&lt;col</span><span class="ot"> style=</span><span class="st">"background-color: yellow"</span><span class="ot"> span=</span><span class="st">"2"</span><span class="kw">&gt;</span></span><span id="cb2-3"><a href="#cb2-3"></a><span class="kw">&lt;/colgroup&gt;</span></span></code></pre></div><h1 id="给表格增加一个标题">给表格增加一个标题</h1><p>使用<code>caption</code>元素。</p><div class="sourceCode" id="cb3"><pre class="sourceCode html"><code class="sourceCode html"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">&lt;table&gt;</span></span><span id="cb3-2"><a href="#cb3-2"></a>  <span class="kw">&lt;caption&gt;</span>Dinosaurs in the Jurassic period<span class="kw">&lt;/caption&gt;</span></span><span id="cb3-3"><a href="#cb3-3"></a></span><span id="cb3-4"><a href="#cb3-4"></a>  ...</span><span id="cb3-5"><a href="#cb3-5"></a><span class="kw">&lt;/table&gt;</span></span></code></pre></div><h1 id="使用一些标签更加结构化表格">使用一些标签更加结构化表格</h1><p>表头：<code>thead</code>、页脚：<code>tfoot</code>、正文：<code>tbody</code>。</p><p>主要是为了方便使用CSS控制表格样式。</p><div class="sourceCode" id="cb4"><pre class="sourceCode html"><code class="sourceCode html"><span id="cb4-1"><a href="#cb4-1"></a></span><span id="cb4-2"><a href="#cb4-2"></a><span class="kw">&lt;table&gt;</span></span><span id="cb4-3"><a href="#cb4-3"></a>  <span class="kw">&lt;caption&gt;</span> ... <span class="kw">&lt;/caption&gt;</span></span><span id="cb4-4"><a href="#cb4-4"></a>  <span class="kw">&lt;thead&gt;</span> <span class="kw">&lt;tr&gt;</span> <span class="kw">&lt;th&gt;&lt;/th&gt;</span> ... <span class="kw">&lt;/tr&gt;</span> <span class="kw">&lt;/thead&gt;</span></span><span id="cb4-5"><a href="#cb4-5"></a>  <span class="kw">&lt;tbody&gt;</span> <span class="kw">&lt;tr&gt;</span> <span class="kw">&lt;td&gt;&lt;/td&gt;</span> ... <span class="kw">&lt;/tr&gt;</span> ... <span class="kw">&lt;/tbody&gt;</span></span><span id="cb4-6"><a href="#cb4-6"></a>  <span class="kw">&lt;tfoot&gt;</span> <span class="kw">&lt;tr&gt;</span> <span class="kw">&lt;td&gt;&lt;/td&gt;</span> ... <span class="kw">&lt;/tr&gt;</span> <span class="kw">&lt;/tbody&gt;</span></span><span id="cb4-7"><a href="#cb4-7"></a><span class="kw">&lt;/table&gt;</span></span></code></pre></div><h1 id="嵌套表格">嵌套表格</h1><p>即在<code>td</code>元素内再写一个完整的<code>table</code>，不推荐使用。</p><h1 id="为视力受损者">为视力受损者</h1><ol type="1"><li>在行标目和列表目分别使用<code>scope="row"</code>和<code>scope="col"</code>来指定其存在，如果这个标目是多个行或列的标题，则使用<code>rowgroup</code>或<code>colgroup</code>；</li><li>为行标目和列表目添加唯一的<code>id</code>，然后在属于其的单元格上加入属性<code>headers</code>，值为其属于的行标目和列表目的<code>id</code>，这样可以表示单元格和行、列直接的关系，便于视力受损者使用阅读器来识别；</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MDN学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML多媒体</title>
      <link href="/2020/05/13/html-duo-mei-ti/"/>
      <url>/2020/05/13/html-duo-mei-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="html图片">HTML图片</h1><p>警告：大多数图片是有版权的。除非是以下的情况，不然不要在你的网页上使用图片：</p><ol type="1"><li>你是图片版权所有者</li><li>你有图片版权所有者明确的、书面上的使用授权</li><li>你有充分的证据证明这张图片是公共领域内的</li></ol><p>侵犯版权是违法并且不道德的。此外，在得到授权之前永远不要把你的src属性指向其他人网站上的图片。这被称为"盗链（hotlinking）"。同样，盗取其他人的带宽也是违法的。而且这会降低你的页面的加载速度，而且图片可能会在不受你控制的情况下被移走或用别的令人尴尬的东西替换掉。</p><blockquote><p><code>&lt;img&gt;</code>或<code>&lt;video&gt;</code>等元素又被称为替换元素，因为其性质完全有其链接的外部资源定义。</p></blockquote><h2 id="替代文本">替代文本</h2><p><code>alt</code>属性：如果是装饰，可以置空。</p><h2 id="宽度和高度">宽度和高度</h2><p>这里设置宽度和高度，必须设置和原始图像一样的大小。这里的设置仅仅是为了如果图片还没有加载出来，会预留出图像的空间，便于网页排版（也有利于网页加载）。</p><p>如果想要改变图像的大小，请使用CSS。</p><h2 id="图像标题">图像标题</h2><p>鼠标悬停的时候会显示，不是很重要。（一般用下面的<code>figcaption</code>）。</p><h2 id="图像的说明文字">图像的说明文字</h2><p>推荐使用<code>figure</code>和<code>figcaption</code>元素:</p><div class="sourceCode" id="cb1"><pre class="sourceCode html"><code class="sourceCode html"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">&lt;figure&gt;</span></span><span id="cb1-2"><a href="#cb1-2"></a>    <span class="kw">&lt;img</span><span class="ot"> src=</span><span class="st">"..."</span><span class="kw">&gt;</span></span><span id="cb1-3"><a href="#cb1-3"></a>    <span class="kw">&lt;img</span><span class="ot"> src=</span><span class="st">"..."</span><span class="kw">&gt;</span></span><span id="cb1-4"><a href="#cb1-4"></a>    <span class="kw">&lt;figcaption&gt;</span>这组图片的标题<span class="kw">&lt;/figcaption&gt;</span></span><span id="cb1-5"><a href="#cb1-5"></a><span class="kw">&lt;/figure&gt;</span></span></code></pre></div><p><code>figure</code>中不一定只是图片，还可以是代码、音频、视频等等，其只是一个独立的内容单元，只要符合：</p><ul><li>用简单、直观的方式表达意图；</li><li>可以置于线性流的某处；</li><li>有主要内容的补充说明；</li></ul><p>即可。</p><h2 id="css背景图片">CSS背景图片</h2><p>如果是为了装饰，使用CSS背景图片（便于控制大小和位置）；</p><p>如果图片有实际的意义，对网页的内容是有意义的，则使用html元素插入。</p><h1 id="html视频">HTML视频</h1><p>其使用的基本格式：</p><div class="sourceCode" id="cb2"><pre class="sourceCode html"><code class="sourceCode html"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">&lt;video</span><span class="ot"> src=</span><span class="st">"rabbit320.webm"</span><span class="ot"> controls</span><span class="kw">&gt;</span></span><span id="cb2-2"><a href="#cb2-2"></a>  <span class="kw">&lt;p&gt;</span>你的浏览器不支持 HTML5 视频。可点击<span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">"rabbit320.mp4"</span><span class="kw">&gt;</span>此链接<span class="kw">&lt;/a&gt;</span>观看<span class="kw">&lt;/p&gt;</span></span><span id="cb2-3"><a href="#cb2-3"></a><span class="kw">&lt;/video&gt;</span></span></code></pre></div><p>或</p><div class="sourceCode" id="cb3"><pre class="sourceCode html"><code class="sourceCode html"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">&lt;video</span><span class="ot"> controls width=</span><span class="st">"400"</span><span class="ot"> height=</span><span class="st">"400"</span></span><span id="cb3-2"><a href="#cb3-2"></a><span class="ot">       autoplay loop muted</span></span><span id="cb3-3"><a href="#cb3-3"></a><span class="ot">       poster=</span><span class="st">"poster.png"</span><span class="kw">&gt;</span></span><span id="cb3-4"><a href="#cb3-4"></a>  <span class="kw">&lt;source</span><span class="ot"> src=</span><span class="st">"rabbit320.mp4"</span><span class="ot"> type=</span><span class="st">"video/mp4"</span><span class="kw">&gt;</span></span><span id="cb3-5"><a href="#cb3-5"></a>  <span class="kw">&lt;source</span><span class="ot"> src=</span><span class="st">"rabbit320.webm"</span><span class="ot"> type=</span><span class="st">"video/webm"</span><span class="kw">&gt;</span></span><span id="cb3-6"><a href="#cb3-6"></a>  <span class="kw">&lt;p&gt;</span>你的浏览器不支持 HTML5 视频。可点击<span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">"rabbit320.mp4"</span><span class="kw">&gt;</span>此链接<span class="kw">&lt;/a&gt;</span>观看<span class="kw">&lt;/p&gt;</span></span><span id="cb3-7"><a href="#cb3-7"></a><span class="kw">&lt;/video&gt;</span></span></code></pre></div><ol type="1"><li><code>src</code>：类似图片；</li><li><code>controls</code>：允许用户能够控制视频和音频的回放功能；</li><li><code>&lt;video&gt;标签内的段落</code>：这个叫做<strong>后备内容</strong> — 当浏览器不支持 <code>&lt;video&gt;</code> 标签的时候，它将会显示出来，它使我们能够对旧的浏览器做一些兼容处理。你可以添加任何后备内容，在这个例子中我们提供了一个指向这个视频文件的链接，从而使用户可以至少访问到这个文件，而不会局限于浏览器的支持。</li><li><code>weight</code>和<code>height</code>：无论怎么设置，视频的长宽比是会被保持的；</li><li><code>autoplay</code>：自动播放，不建议设置；</li><li><code>loop</code>：循环播放，不建议设置；</li><li><code>muted</code>：默认关闭声音；</li><li><code>poster</code>：指向一个图像的url，在视频播放前，用于粗略地显示视频内容或广告；</li><li><code>preload</code>：用来缓冲视频；</li></ol><p>因为兼容性的问题，可能某个格式的视频文件无法被浏览器播放，所以一种可行的方式是放多个不同格式的视频，让浏览器来选择。这就需要把<code>src</code>属性从<code>vedio</code>元素移到内部的<code>soruce</code>元素中，最好加上<code>type</code>属性，这个值可以查阅<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Supported_media_formats" target="_blank" rel="noopener">MIME types</a>得知。</p><h1 id="html音频">HTML音频</h1><p>其基本和<code>video</code>标签一致：</p><div class="sourceCode" id="cb4"><pre class="sourceCode html"><code class="sourceCode html"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">&lt;audio</span><span class="ot"> controls</span><span class="kw">&gt;</span></span><span id="cb4-2"><a href="#cb4-2"></a>  <span class="kw">&lt;source</span><span class="ot"> src=</span><span class="st">"viper.mp3"</span><span class="ot"> type=</span><span class="st">"audio/mp3"</span><span class="kw">&gt;</span></span><span id="cb4-3"><a href="#cb4-3"></a>  <span class="kw">&lt;source</span><span class="ot"> src=</span><span class="st">"viper.ogg"</span><span class="ot"> type=</span><span class="st">"audio/ogg"</span><span class="kw">&gt;</span></span><span id="cb4-4"><a href="#cb4-4"></a>  <span class="kw">&lt;p&gt;</span>你的浏览器不支持 HTML5 音频，可点击<span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">"viper.mp3"</span><span class="kw">&gt;</span>此链接<span class="kw">&lt;/a&gt;</span>收听。<span class="kw">&lt;/p&gt;</span></span><span id="cb4-5"><a href="#cb4-5"></a><span class="kw">&lt;/audio&gt;</span></span></code></pre></div><p>区别：其不支持<code>width/height</code>和<code>poster</code>属性。</p><h1 id="html嵌入">HTML嵌入</h1><p>Youtube视频--&gt;共享--&gt;嵌入--&gt;得到一段<code>&lt;iframe&gt;</code>代码，将这段代码加入HTML文件，有如下效果： <img src="/2020/05/13/html-duo-mei-ti/HTML多媒体_2020-05-14-09-45-19.png" alt="Youtube视频嵌入"></p><h2 id="iframe嵌入">iframe嵌入</h2><p><code>&lt;iframe&gt;</code>旨在将其他web文档嵌入当前文档中，这个web文档本身无法直接控制，但这对于某些需求足够了，比如：视频、评论系统、在线地图、广告横幅等等。</p><p>以为是<code>&lt;iframe&gt;</code>的示例：</p><div class="sourceCode" id="cb5"><pre class="sourceCode html"><code class="sourceCode html"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">&lt;iframe</span><span class="ot"> src=</span><span class="st">"https://developer.mozilla.org/en-US/docs/Glossary"</span></span><span id="cb5-2"><a href="#cb5-2"></a><span class="ot">        width=</span><span class="st">"100%"</span><span class="ot"> height=</span><span class="st">"500"</span><span class="ot"> frameborder=</span><span class="st">"0"</span></span><span id="cb5-3"><a href="#cb5-3"></a><span class="ot">        allowfullscreen sandbox</span><span class="kw">&gt;</span></span><span id="cb5-4"><a href="#cb5-4"></a>  <span class="kw">&lt;p&gt;</span> <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">"https://developer.mozilla.org/en-US/docs/Glossary"</span><span class="kw">&gt;</span></span><span id="cb5-5"><a href="#cb5-5"></a>    Fallback link for browsers that don't support iframes</span><span id="cb5-6"><a href="#cb5-6"></a>  <span class="kw">&lt;/a&gt;</span> <span class="kw">&lt;/p&gt;</span></span><span id="cb5-7"><a href="#cb5-7"></a><span class="kw">&lt;/iframe&gt;</span></span></code></pre></div><ul><li><code>allowfullscreen</code>：如果设置，<code>&lt;iframe&gt;</code>则可以通过全屏API设置为全屏模式（稍微超出本文的范围）。</li><li><code>frameborder</code>：如果设置为1，则会告诉浏览器在此框架和其他框架之间绘制边框，这是默认行为。0删除边框。不推荐这样设置，因为在CSS中可以更好地实现相同的效果。</li><li><code>src</code>：该属性与<code>&lt;video&gt;</code>/<code>&lt;img&gt;</code>一样包含指向要嵌入文档的URL路径。为了提高速度，在主内容完成加载后，使用JavaScript设置iframe的src属性是个好主意。这使您的页面可以更快地被使用，并减少您的官方页面加载时间（重要的SEO指标）。</li><li><code>width</code>和<code>height</code>：高度和宽度；</li><li>备选内容：与<code>&lt;video&gt;</code>等其他类似元素相同，您可以在<code>&lt;iframe&gt;&lt;/iframe&gt;</code>标签之间包含备选内容，如果浏览器不支持<code>&lt;iframe&gt;</code>，将会显示备选内容，这种情况下，我们已经添加了一个到该页面的链接。现在您几乎不可能遇到任何不支持<code>&lt;iframe&gt;</code>的浏览器。</li><li><code>sandbox</code>：该属性需要在已经支持其他<code>&lt;iframe&gt;</code>功能（例如IE 10及更高版本）但稍微更现代的浏览器上才能工作，该属性可以提高安全性设置。应该始终使用它。</li></ul><h2 id="embed和object">embed和object</h2><p><code>&lt;embed&gt;</code>和<code>&lt;object&gt;</code>元素的功能不同于<code>&lt;iframe&gt;</code>—— 这些元素是用来嵌入多种类型的外部内容的通用嵌入工具，其中包括像Java小程序和Flash，PDF（可在浏览器中显示为一个PDF插件）这样的插件技术，甚至像视频，SVG和图像的内容。（当然，要么有更好的元素来实现，要么已经过时，碰到的机会很少了。） <img src="/2020/05/13/html-duo-mei-ti/HTML多媒体_2020-05-14-09-58-48.png" alt="embed和object的用法"></p><p>例子1（<code>embed</code>嵌入flash影片）：</p><div class="sourceCode" id="cb6"><pre class="sourceCode html"><code class="sourceCode html"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">&lt;embed</span><span class="ot"> src=</span><span class="st">"whoosh.swf"</span><span class="ot"> quality=</span><span class="st">"medium"</span></span><span id="cb6-2"><a href="#cb6-2"></a><span class="ot">       bgcolor=</span><span class="st">"#ffffff"</span><span class="ot"> width=</span><span class="st">"550"</span><span class="ot"> height=</span><span class="st">"400"</span></span><span id="cb6-3"><a href="#cb6-3"></a><span class="ot">       name=</span><span class="st">"whoosh"</span><span class="ot"> align=</span><span class="st">"middle"</span><span class="ot"> allowScriptAccess=</span><span class="st">"sameDomain"</span></span><span id="cb6-4"><a href="#cb6-4"></a><span class="ot">       allowFullScreen=</span><span class="st">"false"</span><span class="ot"> type=</span><span class="st">"application/x-shockwave-flash"</span></span><span id="cb6-5"><a href="#cb6-5"></a><span class="ot">       pluginspage=</span><span class="st">"http://www.macromedia.com/go/getflashplayer"</span><span class="kw">&gt;</span></span></code></pre></div><p>例子2（<code>object</code>嵌入pdf）：</p><div class="sourceCode" id="cb7"><pre class="sourceCode html"><code class="sourceCode html"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">&lt;object</span><span class="ot"> data=</span><span class="st">"mypdf.pdf"</span><span class="ot"> type=</span><span class="st">"application/pdf"</span></span><span id="cb7-2"><a href="#cb7-2"></a><span class="ot">        width=</span><span class="st">"800"</span><span class="ot"> height=</span><span class="st">"1200"</span><span class="ot"> typemustmatch</span><span class="kw">&gt;</span></span><span id="cb7-3"><a href="#cb7-3"></a>  <span class="kw">&lt;p&gt;</span>You don't have a PDF plugin, but you can <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">"myfile.pdf"</span><span class="kw">&gt;</span>download the PDF file.<span class="kw">&lt;/a&gt;&lt;/p&gt;</span></span><span id="cb7-4"><a href="#cb7-4"></a><span class="kw">&lt;/object&gt;</span></span></code></pre></div><h1 id="html矢量图">HTML矢量图</h1><ul><li>位图使用像素网格来定义 — 一个位图文件精确得包含了每个像素的位置和它的色彩信息。流行的位图格式包括 Bitmap (<code>.bmp</code>), PNG (<code>.png</code>), JPEG (<code>.jpg</code>), and GIF (<code>.gif</code>)。</li><li>矢量图使用算法来定义 — 一个矢量图文件包含了图形和路径的定义，电脑可以根据这些定义计算出当它们在屏幕上渲染时应该呈现的样子。 <code>SVG</code> 格式可以让我们创造用于 Web 的精彩的矢量图形。</li></ul><p><code>SVG</code> 是用于描述矢量图像的XML语言。 它基本上是像HTML一样的标记，只是你有许多不同的元素来定义要显示在图像中的形状，以及要应用于这些形状的效果。 SVG用于标记图形，而不是内容。 非常简单，你有一些元素来创建简单图形，如<code>&lt;circle&gt;</code> 和<code>&lt;rect&gt;</code>。更高级的SVG功能包括 <code>&lt;feColorMatrix&gt;</code>（使用变换矩阵转换颜色）<code>&lt;animate&gt;</code> （矢量图形的动画部分）和 <code>&lt;mask&gt;</code>（在图像顶部应用模板）。</p><p>比如下面的例子创建了一个圆和矩形：</p><div class="sourceCode" id="cb8"><pre class="sourceCode html"><code class="sourceCode html"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">&lt;svg</span><span class="ot"> version=</span><span class="st">"1.1"</span></span><span id="cb8-2"><a href="#cb8-2"></a><span class="ot">     baseProfile=</span><span class="st">"full"</span></span><span id="cb8-3"><a href="#cb8-3"></a><span class="ot">     width=</span><span class="st">"300"</span><span class="ot"> height=</span><span class="st">"200"</span></span><span id="cb8-4"><a href="#cb8-4"></a><span class="ot">     xmlns=</span><span class="st">"http://www.w3.org/2000/svg"</span><span class="kw">&gt;</span></span><span id="cb8-5"><a href="#cb8-5"></a>  <span class="kw">&lt;rect</span><span class="ot"> width=</span><span class="st">"100%"</span><span class="ot"> height=</span><span class="st">"100%"</span><span class="ot"> fill=</span><span class="st">"black"</span> <span class="kw">/&gt;</span></span><span id="cb8-6"><a href="#cb8-6"></a>  <span class="kw">&lt;circle</span><span class="ot"> cx=</span><span class="st">"150"</span><span class="ot"> cy=</span><span class="st">"100"</span><span class="ot"> r=</span><span class="st">"90"</span><span class="ot"> fill=</span><span class="st">"blue"</span> <span class="kw">/&gt;</span></span><span id="cb8-7"><a href="#cb8-7"></a><span class="kw">&lt;/svg&gt;</span></span></code></pre></div><svg version="1.1" baseProfile="full" width="300" height="200" xmlns="http://www.w3.org/2000/svg"><rect width="100%" height="100%" fill="black"></rect> <circle cx="150" cy="100" r="90" fill="blue"></circle></svg><p>但用<code>svg</code>绘制复杂的图像会导致一些问题（文件太大，处理时间长等），所以储存照片等复杂精密的图像时一般还是使用位图。</p><h2 id="插入方式1">插入方式1</h2><p>使用<code>img</code>，像插入一张普通图片一样插入，只是需要提供<code>width</code>或<code>height</code>。</p><div class="sourceCode" id="cb9"><pre class="sourceCode html"><code class="sourceCode html"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">&lt;img</span></span><span id="cb9-2"><a href="#cb9-2"></a><span class="ot">    src=</span><span class="st">"equilateral.svg"</span></span><span id="cb9-3"><a href="#cb9-3"></a><span class="ot">    alt=</span><span class="st">"triangle with all three sides equal"</span></span><span id="cb9-4"><a href="#cb9-4"></a><span class="ot">    height=</span><span class="st">"87px"</span></span><span id="cb9-5"><a href="#cb9-5"></a><span class="ot">    width=</span><span class="st">"100px"</span> <span class="kw">/&gt;</span></span></code></pre></div><p>优点：</p><ul><li>快速，熟悉的图像语法与<code>alt</code>属性中提供的内置文本等效。</li><li>可以通过在<code>&lt;a&gt;</code>元素嵌套<code>&lt;img&gt;</code>，使图像轻松地成为超链接。</li></ul><p>缺点：</p><ul><li>无法使用JavaScript操作图像。</li><li>如果要使用CSS控制SVG内容，则必须在SVG代码中包含内联CSS样式。 （从SVG文件调用的外部样式表不起作用）</li><li>不能用CSS伪类来重设图像样式（如:<code>focus</code>）。</li></ul><h2 id="插入方式2">插入方式2</h2><p>这称为<strong>SVG内联</strong>或<strong>内联SVG</strong>。打开SVG文件，复制SVG代码，并将其粘贴到HTML文档中。确保您的SVG代码在<code>&lt;svg&gt;&lt;/svg&gt;</code>标签中。</p><div class="sourceCode" id="cb10"><pre class="sourceCode html"><code class="sourceCode html"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">&lt;svg</span><span class="ot"> width=</span><span class="st">"300"</span><span class="ot"> height=</span><span class="st">"200"</span><span class="kw">&gt;</span></span><span id="cb10-2"><a href="#cb10-2"></a>    <span class="kw">&lt;rect</span><span class="ot"> width=</span><span class="st">"100%"</span><span class="ot"> height=</span><span class="st">"100%"</span><span class="ot"> fill=</span><span class="st">"green"</span> <span class="kw">/&gt;</span></span><span id="cb10-3"><a href="#cb10-3"></a><span class="kw">&lt;/svg&gt;</span></span></code></pre></div><p>优点：</p><ul><li>将 SVG 内联减少 HTTP 请求，可以减少加载时间。</li><li>您可以为 SVG 元素分配<code>class</code>和<code>id</code>，并使用 CSS 修改样式，无论是在SVG中，还是 HTML 文档中的 CSS 样式规则。 实际上，您可以使用任何 SVG外观属性 作为CSS属性。</li><li>内联SVG是唯一可以让您在SVG图像上使用CSS交互（如:<code>focus</code>）和CSS动画的方法（即使在常规样式表中）。</li><li>您可以通过将 SVG 标记包在<code>&lt;a&gt;</code>元素中，使其成为超链接。</li></ul><p>缺点：</p><ul><li>这种方法只适用于在一个地方使用的SVG。多次使用会导致资源密集型维护（resource-intensive maintenance）。</li><li>额外的 SVG 代码会增加HTML文件的大小。</li><li>浏览器不能像缓存普通图片一样缓存内联SVG。</li><li>您可能会在<code>&lt;foreignObject&gt;</code> 元素中包含回退，但支持 SVG 的浏览器仍然会下载任何后备图像。你需要考虑仅仅为支持过时的浏览器，而增加额外开销是否真的值得。</li></ul><h2 id="插入方式3">插入方式3</h2><p>使用<code>iframe</code>，这里提供了一种想法，但这一定不是一个好主意。</p><div class="sourceCode" id="cb11"><pre class="sourceCode html"><code class="sourceCode html"><span id="cb11-1"><a href="#cb11-1"></a><span class="kw">&lt;iframe</span><span class="ot"> src=</span><span class="st">"triangle.svg"</span><span class="ot"> width=</span><span class="st">"500"</span><span class="ot"> height=</span><span class="st">"500"</span><span class="ot"> sandbox</span><span class="kw">&gt;</span></span><span id="cb11-2"><a href="#cb11-2"></a>    <span class="kw">&lt;img</span><span class="ot"> src=</span><span class="st">"triangle.png"</span><span class="ot"> alt=</span><span class="st">"Triangle with three unequal sides"</span> <span class="kw">/&gt;</span></span><span id="cb11-3"><a href="#cb11-3"></a><span class="kw">&lt;/iframe&gt;</span></span></code></pre></div><h1 id="响应式图片">响应式图片</h1><p>网页图片在电脑上看着不错，但到手机上因为屏幕大小发生了改变，我们希望图像的大小也随之发生变化，即响应式开发。</p><h2 id="创建响应式的图片">创建响应式的图片</h2><p>也可以使用CSS重建，但这里专注于HTML的<code>&lt;img&gt;</code>。</p><div class="sourceCode" id="cb12"><pre class="sourceCode html"><code class="sourceCode html"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">&lt;img</span><span class="ot"> srcset=</span><span class="st">"elva-fairy-320w.jpg 320w,</span></span><span id="cb12-2"><a href="#cb12-2"></a><span class="st">             elva-fairy-480w.jpg 480w,</span></span><span id="cb12-3"><a href="#cb12-3"></a><span class="st">             elva-fairy-800w.jpg 800w"</span></span><span id="cb12-4"><a href="#cb12-4"></a><span class="ot">     sizes=</span><span class="st">"(max-width: 320px) 280px,</span></span><span id="cb12-5"><a href="#cb12-5"></a><span class="st">            (max-width: 480px) 440px,</span></span><span id="cb12-6"><a href="#cb12-6"></a><span class="st">            800px"</span></span><span id="cb12-7"><a href="#cb12-7"></a><span class="ot">     src=</span><span class="st">"elva-fairy-800w.jpg"</span><span class="ot"> alt=</span><span class="st">"Elva dressed as a fairy"</span><span class="kw">&gt;</span></span></code></pre></div><ul><li>srcset定义了我们允许浏览器选择的图像集，以及每个图像的大小，使用逗号分隔每个图像，而使用空格隔开文件名和固有宽度。</li><li>sizes定义了一组媒体条件（例如屏幕宽度）并且指明当某些媒体条件为真时，什么样的图片尺寸是最佳选择—我们在之前已经讨论了一些提示。没有写媒体条件的选项表示其他都不符合时，选择此。</li></ul><blockquote><p><strong>这里关于w单位的图片大小我并没有找到...??</strong></p></blockquote><blockquote><p>注意: 在 HTML 文件中的 <code>&lt;head&gt;</code> 标签里， 你将会找到这一行代码 <code>&lt;meta name="viewport" content="width=device-width"&gt;</code>: 这行代码会强制地让手机浏览器采用它们真实可视窗口的宽度来加载网页（有些手机浏览器会提供不真实的可视窗口宽度, 然后加载比浏览器真实可视窗口的宽度大的宽度的网页，然后再缩小加载的页面，这样的做法对响应式图片或其他设计，没有任何帮助。我们会在未来的模块教给你更多关于这方面的知识）。</p></blockquote><p>当屏幕尺寸相同，但希望在不同分辨率上显示不同大小的图片，则使用下面的语法：</p><div class="sourceCode" id="cb13"><pre class="sourceCode html"><code class="sourceCode html"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">&lt;img</span><span class="ot"> srcset=</span><span class="st">"elva-fairy-320w.jpg,</span></span><span id="cb13-2"><a href="#cb13-2"></a><span class="st">             elva-fairy-480w.jpg 1.5x,</span></span><span id="cb13-3"><a href="#cb13-3"></a><span class="st">             elva-fairy-640w.jpg 2x"</span></span><span id="cb13-4"><a href="#cb13-4"></a><span class="ot">     src=</span><span class="st">"elva-fairy-640w.jpg"</span><span class="ot"> alt=</span><span class="st">"Elva dressed as a fairy"</span><span class="kw">&gt;</span></span></code></pre></div><h2 id="美术设计问题">美术设计问题</h2><p>另一个问题：有一张宽屏、大的、横向图片，在电脑上显示的很好，但当来到收集，图像会被缩小，里面的人物无法很好的显示，最好的方式是在此时使用一张小的肖像图来替代，怎么做到？</p><div class="sourceCode" id="cb14"><pre class="sourceCode html"><code class="sourceCode html"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">&lt;picture&gt;</span></span><span id="cb14-2"><a href="#cb14-2"></a>  <span class="kw">&lt;source</span><span class="ot"> media=</span><span class="st">"(max-width: 799px)"</span><span class="ot"> srcset=</span><span class="st">"elva-480w-close-portrait.jpg"</span><span class="kw">&gt;</span></span><span id="cb14-3"><a href="#cb14-3"></a>  <span class="kw">&lt;source</span><span class="ot"> media=</span><span class="st">"(min-width: 800px)"</span><span class="ot"> srcset=</span><span class="st">"elva-800w.jpg"</span><span class="kw">&gt;</span></span><span id="cb14-4"><a href="#cb14-4"></a>  <span class="kw">&lt;img</span><span class="ot"> src=</span><span class="st">"elva-800w.jpg"</span><span class="ot"> alt=</span><span class="st">"Chris standing up holding his daughter Elva"</span><span class="kw">&gt;</span></span><span id="cb14-5"><a href="#cb14-5"></a><span class="kw">&lt;/picture&gt;</span></span></code></pre></div><p>上述使用的<code>img</code>是在浏览器不支持<code>picture</code>时的一个备选方案。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MDN学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML基础</title>
      <link href="/2020/05/13/html-ji-chu/"/>
      <url>/2020/05/13/html-ji-chu/</url>
      
        <content type="html"><![CDATA[<p><strong>HTML (HyperText Markup Language)</strong> 不是一门编程语言，而是一种用来告知浏览器如何组织页面的标记语言。HTML 可复杂、可简单，一切取决于开发者。它由一系列的<strong>元素（elements）</strong>组成，这些元素可以用来包围不同部分的内容，使其以某种方式呈现或者工作。</p><h1 id="html元素">HTML元素</h1><h2 id="html元素的分类">HTML元素的分类</h2><ul><li><p>块级元素</p><p>其可以包含块级元素或内联元素；但不能被内联元素包含。</p></li><li><p>内联元素</p><p>通常出现在块级元素中，可以包含另一个内联元素。</p></li><li><p>空元素 （Empty elements、void elements）</p><p>只有开始标签而没有结束标签的元素，因为其不需要包裹内容，所以去掉了结束标签。</p><p>如：<code>br</code>、<code>img</code>、<code>hr</code>等。</p></li></ul><blockquote><p>实际上这里的“块”和“内联”，和CSS boxes模型中定义的display同名术语不是一个东西（尽管它们两者之间关系非常密切），改变其CSS display值并不会改变此元素的分类，<strong>更不会改变其可以包含和被包含的元素类型</strong>。</p></blockquote><blockquote><p>所以HTML5中改变了其分类的标准（但新的分类太复杂难懂了，:)）。</p></blockquote><h2 id="html元素的属性">HTML元素的属性</h2><ul><li><p>布尔属性：有时候不需要值的属性，其存在代表属性值为<code>true</code>； <img src="/2020/05/13/html-ji-chu/HTML基础_2020-05-13-19-12-41.png"></p></li><li><p>使用属性时，其值需要用引号引起来，双引号和单引号都可以，但必须统一，嵌套引号时需要使用不同类型的引号；</p></li></ul><h2 id="html实体引用">HTML实体引用</h2><p>就是使用字符引用来生成构筑元素标签的特殊字符（都是用<code>&amp;</code>和<code>;</code>包裹形成的）：</p><ul><li><code>&lt;</code> == <code>&amp;lt;</code></li><li><code>&gt;</code> == <code>&amp;gt;</code></li><li><code>"</code> == <code>&amp;quot;</code></li><li><code>'</code> == <code>&amp;apos;</code></li><li><code>&amp;</code> == <code>&amp;amp;</code></li></ul><p><a href="http://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references" target="_blank" rel="noopener">wiki上的XML和HTML的字符实体引用列表</a>。</p><h1 id="html中的元数据meta-data">HTML中的元数据（meta-data）</h1><p>meta-data是放在<code>&lt;head&gt;</code>中的元素。</p><p>一般使用vscode会自动创建补充：</p><ol class="example" type="1"><li><code>&lt;title&gt;</code>，是页面标签上的文本；</li><li><code>&lt;meta charset="UTF-8"&gt;</code></li></ol><p>我们还可以添加：</p><ol start="3" class="example" type="1"><li><code>&lt;meta name="author" content="Chris Mills"&gt;</code></li><li><code>&lt;meta name="description" content="The MDN Learning Area aims to provide ..."&gt;</code></li></ol><p>以上4个元素可以被搜索引擎捕获，并可能会让页面出现在相关搜索中的次数更多（SEO）。</p><ol start="5" class="example" type="1"><li><code>&lt;link rel="shortcut icon" href="favicon.ico" type="image/x-icon"&gt;</code>，来增加自定义图标，当然可以增加多个，来针对不同的设备</li><li><code>&lt;link rel="stylesheet" href="my-css-file.css"&gt;</code>，来增加css文件的引用</li><li><del><code>&lt;script src="my-js-file.js"&gt;&lt;/script&gt;</code>，引入js文件，但这个一般来说不放在头部，而是放在页面的最后（<code>&lt;/body&gt;</code>前面），这有利于页面的快速加载。</del></li></ol><p>另外还有一个并不是放在<code>&lt;header&gt;</code>内的属性，<code>&lt;html lang="zh-CN"&gt;</code>，当然，这个属性可以设置到其他文本标签（比如<code>p</code>、<code>span</code>）中，来只改变一部分文本的语言。</p><h1 id="html链接">HTML链接</h1><ol type="1"><li>记得添加<code>title</code>属性，这是支持信息，有益于有视觉障碍的读者使用；</li><li>尽量使用相对路径；</li><li>下载的时候，可以使用<code>download</code>属性来指定默认的保存文件名；</li></ol><h1 id="html文本">HTML文本</h1><p>结构化。</p><p>最重要的：<strong>语义化</strong>。</p><p>一些高级文本元素：</p><ol type="1"><li><p>描述列表（description list）：</p><p><code>&lt;dl&gt;&lt;dt&gt;&lt;dd&gt;</code></p></li><li><p>引用：</p><p>块引用：<code>&lt;blockquote cite="本段内容引用的资源"&gt;</code> 行内引用：<code>&lt;q&gt;</code>，渲染时会加上引号</p></li><li><p>缩略语：</p><p><code>&lt;abbr title="全称"&gt;</code></p></li><li><p>标记地址：</p><p><code>&lt;address&gt;</code></p></li><li><p>上标和下标：</p><p><code>sup</code>和<code>sub</code></p></li><li><p>展现计算机代码：</p><ul><li><code>code</code>：标记计算机通用代码；</li><li><code>pre</code>：在此元素内的文本，其多余的空格和缩进会被保留；</li><li><code>var</code>：来包裹一个变量名（效果其实和斜体差不多）；</li><li><code>kbd</code>：用来标记键盘输入（比如<code>Ctrl</code>、<code>Shift</code>等等）；</li><li><code>samp</code>：标记程序的输出；</li></ul><p>一般代码使用<code>&lt;pre&gt;&lt;code&gt;...&lt;/code&gt;&lt;/pre&gt;</code>包裹，然后再用其他的来修饰。</p></li><li><p>日期和时间：</p><p><code>&lt;time date="2020-01-01"&gt;2020年一月一日&lt;/time&gt;</code></p><p>便于计算机处理，这样不论文本是什么样的格式，都可以被计算机识别。</p></li></ol><h1 id="html文档架构">HTML文档架构</h1><p>基于语义化的要求，还有一些用来布局的专用的块级标签，这里结合一个常用的布局来进行解释：</p><p><img src="/2020/05/13/html-ji-chu/HTML基础_2020-05-13-22-40-28.png"></p><p>以上是MDN练习的一个网站，其可以分为以下几个部分：</p><ul><li>页眉：主要包含页面的标题和标志，同一个网站的不同网页一般会有相同的页眉，使用元素<code>&lt;header&gt;</code>来标记；</li><li>（导航栏）：有时候是单独列出来，有时候是放在页眉里面，导航栏在同一个网站的不同页面间应该也是一致的，使用元素<code>&lt;nav&gt;</code>来标记；</li><li>主内容：当前网页的主要内容，视频、文章、地图、新闻等等，不同网页不一样，使用元素<code>&lt;main&gt;</code>来标记；<ul><li>一个页面的内容可能被再进行分割，比如一个页面可以放置多篇文章（则每一篇文章都使用<code>&lt;article&gt;</code>来标记），或者页面里有多个部分的内容（则每一部分可以使用<code>&lt;secton&gt;</code>来标记），或者两者都存在，或者可能存在嵌套；</li><li>有可能每个<code>&lt;article&gt;</code>或<code>&lt;section&gt;</code>都有自己的<code>&lt;header&gt;</code>；</li></ul></li><li>（侧边栏），可以是主内容的一部分，也可以不是（一般是在<code>&lt;main&gt;</code>里面的），放在两侧，可以是一些广告、相关链接、外围信息、目录、作者简介、属于条目等，一般来说和主内容有关联，也可以在不同页面间保持重复，使用元素<code>&lt;aside&gt;</code>来标记；</li><li>页脚，底部的狭长区域，一般和标题一样，用来放置公共信息（版权声明或联系方式等），一般使用较小字体，使用<code>&lt;footer&gt;</code>来标记；</li></ul><p>可能有时候，现有的语义标签无法满足我们的要求，则可以使用<code>&lt;div&gt;</code>和<code>&lt;span&gt;</code>这两个无语义的标签，配合<code>class</code>属性来标记，但注意，这两个元素应尽量少用。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MDN学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客搭建</title>
      <link href="/2020/05/10/blog-build/"/>
      <url>/2020/05/10/blog-build/</url>
      
        <content type="html"><![CDATA[<p>自己在学习的过程中，积累了大量的学习材料和笔记。对于增量学习过程，这些学习材料和笔记应该得到较好的组织，而且有些内容很容易因为不常使用而忘记。所以将其进行有条理的整理，便于进行随时查阅，是非常有必要的。</p><p>显然，搭建一个个人博客是一个比较合适的选择。我希望我的个人博客能够满足下面的特点：</p><ul><li>漂亮，好看，逼格满满。</li><li>拥有足够的表现力，可以满足我的多种需求（比如学习笔记、论文笔记等）。</li><li>可以自动化处理多种格式的文件（比如<code>.ipynb</code>和<code>.Rmd</code>，这些文件是我学习python和R时常使用的格式）。</li><li>可以进行自定义修改。</li></ul><p>经过一番的折腾，我选择了vscode + Hexo + pandoc + github page + 脚本辅助的模式。我希望它能够满足我的以上的需求：</p><ul><li>vscode借助其各种插件（vim、Paste Image等）可以实现舒适的文本编辑体验。</li><li>Hexo有各种漂亮的主题，简单的操作就可以定制化一个漂亮的个人博客；Hexo也有各种js脚本制作的插件，可以实现更多的功能以（字数统计、词云、插入音乐等）。</li><li>pandoc版的markdown拥有比传统markdown更多的语法，更强的表现力。</li><li>github page提供了免费的静态网页托管站点，而且依托其issue还可以增加评论功能。</li><li>通过python、js等脚本语言，可以进一步扩宽Hexo的功能（编写新的Hexo脚本），这样我们可以将更多类型的文本整合到博客系统中，并且进行高度的自定义。</li></ul><p>现在，我将我搭建博客的全过程进行记录，以便于发现问题和总结，并探索一个快速的、可重复的操作步骤。</p><h1 id="第一部分-依赖安装">第一部分 依赖安装</h1><h2 id="git安装">1. git安装</h2><p>对于linux系统，使用root权限下的包管理器安装即可；对于windows，使用可执行安装文件，一步一步根据引导即可完成安装。</p><h2 id="node.js安装">2. node.js安装</h2><p>如果是windows系统，同样使用引导界面安装即可。</p><p>如果是linux系统，除了使用包管理器安装以外，还可以使用下面的方式（不需要root权限，便于管理）:</p><ol type="1"><li>从<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">node官网</a>中下载linux的2进制安装包；</li><li><code>tar -Jxvf node-v12.16.3-linux-x64.tar.xz</code>，解压；</li><li>（创建<code>.local/bin</code>，没有必要将这个路径加入到环境变量中，其默认就在环境变量中），将<code>bin/node</code>（别忘了<code>npm</code>和<code>npx</code>）软连接到<code>.local/bin</code>中；</li><li><code>node -v</code>查看是否成功。</li></ol><h2 id="hexo安装">3. Hexo安装</h2><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo</a>依赖于<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">git</a>和<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">node.js</a>，其作为node.js的一个软件包存在的，可以使用npm进行安装管理。</p><blockquote><p>这里需要介绍以下<code>npm</code>的规则，其默认是局部安装模式。如果使用全局安装模式（<code>-g</code>），则相关内容会被安装到<code>prefix/lib/node_modules</code>中（可以使用<code>npm help npm</code>来查看，windows是在C盘下面）。如果是局部安装模式，则相关内容会被安装到当前的文件夹下的node_modules中。</p></blockquote><p>为了提高npm的安装速度，可以<a href="https://blog.csdn.net/quuqu/article/details/64121812" target="_blank" rel="noopener">设置一下淘宝镜像</a>或使用<a href="https://developer.aliyun.com/mirror/NPM" target="_blank" rel="noopener"><code>cnpm</code></a>，然后全局安装hexo-cli（全局安装可以使得我们在任何位置使用<code>hexo</code>命令）：</p><div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1"></a><span class="ex">npm</span> config set registry https://registry.npm.taobao.org</span><span id="cb1-2"><a href="#cb1-2"></a><span class="ex">npm</span> install hexo-cli -g</span></code></pre></div><p>注意，如果在linux上解压二进制安装包安装的node.js，则其全局安装位置可能并不在环境变量中，需要手动再将<code>hexo</code>加入环境变量才好使用。</p><h2 id="pandoc部分">4. Pandoc部分</h2><p>其安装和node.js的安装方式类似，比照其安装即可。</p><h2 id="vscode">5. vscode</h2><p>vscode的安装不再赘述，这里侧重于工作流程、配置和一些好用的插件。</p><p>整个工作流程可以是这样的：</p><ol type="1"><li>直接在<code>_posts</code>文件夹下创建工作环境，编辑markdown文件，需要导入图片的时候，就在其同级目录下创建一个同名文件夹，将图片放入其中来引用即可（使用<a href="https://marketplace.visualstudio.com/items?itemName=mushan.vscode-paste-image" target="_blank" rel="noopener">Paste Image</a>插件可以自动创建这个目录）。</li><li>因为所有的markdown文件都必须在<code>_post</code>目录下，所以为了容易区分，文件命名很重要，可以使用<code>-</code>来增加可读性，比如关于pytorch的学习可以使用<code>python-pytorch-xx</code>、论文的阅读总结可以使用<code>paper-xx</code>。</li></ol><h2 id="paste-image">5.1 <a href="https://marketplace.visualstudio.com/items?itemName=mushan.vscode-paste-image" target="_blank" rel="noopener">Paste Image</a></h2><p>其作用是可以将剪切板中的图片直接放入markdown中（快捷键为C-A-v），并保存到指定的文件夹下。我对此插件进行了下列配置：</p><ol type="1"><li>保存剪切板图片的时候，使用当前正在编辑的文件的名称作为图片文件名称的前缀，使用时间作为其名称的主题；</li><li>设置其保存路径为当前文件同级目录下的同名文件夹；</li><li>在保存图片的时候，会出现vscode input box，从而可以更改路径； <img src="/2020/05/10/blog-build/BlogBuild_2020-05-10-18-03-00.png" alt="PasteImage的配置"></li></ol><h1 id="第二部分-配置博客">第二部分 配置博客</h1><p>本次博客配置使用的主题为<a href="https://github.com/blinkfox/hexo-theme-matery.git" target="_blank" rel="noopener">hexo-theme-matery</a>，其有比较全面的<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" target="_blank" rel="noopener">中文配置说明</a>。另外，博客的配置还参考了两位大佬 -- <a href="https://zhuanlan.zhihu.com/p/35668237" target="_blank" rel="noopener">godweiyang</a>和<a href="https://qinnian.xyz/CreateBlog.html" target="_blank" rel="noopener">钦の念</a>的配置过程，受益匪浅。</p><p>另外，在配置过程中，为了添加更多的功能，安装了众多的hexo插件，这些插件都集中记录在此：</p><div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1"></a><span class="co"># --save表示安装使用依赖</span></span><span id="cb2-2"><a href="#cb2-2"></a><span class="ex">npm</span> install hexo-deployer-git --save           <span class="co"># 用于进行git部署</span></span><span id="cb2-3"><a href="#cb2-3"></a><span class="ex">npm</span> install hexo-wordcount --save              <span class="co"># 统计文章字数</span></span><span id="cb2-4"><a href="#cb2-4"></a><span class="ex">npm</span> install gitalk --save                      <span class="co"># gitalk评论系统</span></span><span id="cb2-5"><a href="#cb2-5"></a><span class="ex">npm</span> install valine --save                      <span class="co"># valine评论系统</span></span><span id="cb2-6"><a href="#cb2-6"></a><span class="ex">npm</span> install hexo-prism-plugin --save           <span class="co"># 代码高亮</span></span><span id="cb2-7"><a href="#cb2-7"></a><span class="ex">npm</span> install hexo-generator-search --save       <span class="co"># 搜索</span></span><span id="cb2-8"><a href="#cb2-8"></a><span class="ex">npm</span> install hexo-permalink-pinyin --save       <span class="co"># 汉字转拼音</span></span><span id="cb2-9"><a href="#cb2-9"></a><span class="ex">npm</span> install hexo-filter-github-emojis --save   <span class="co"># emojis表情</span></span><span id="cb2-10"><a href="#cb2-10"></a><span class="ex">npm</span> install hexo-generator-feed --save         <span class="co"># RSS订阅</span></span><span id="cb2-11"><a href="#cb2-11"></a><span class="ex">npm</span> install https://github.com/xcodebuild/hexo-asset-image --save</span><span id="cb2-12"><a href="#cb2-12"></a><span class="ex">npm</span> install hexo-renderer-pandoc --save</span><span id="cb2-13"><a href="#cb2-13"></a><span class="ex">npm</span> install hexo-helper-live2d --save          <span class="co"># 动画人物支持</span></span><span id="cb2-14"><a href="#cb2-14"></a><span class="ex">npm</span> install live2d-widget-model-shizuku --save <span class="co"># 动画人物支持</span></span><span id="cb2-15"><a href="#cb2-15"></a><span class="ex">npm</span> install hexo-generator-sitemap --save      <span class="co"># 添加站点地图</span></span><span id="cb2-16"><a href="#cb2-16"></a><span class="ex">npm</span> install hexo-lazyload-image --save         <span class="co"># 图片懒加载</span></span></code></pre></div><h2 id="创建站点">1. 创建站点</h2><ol type="1"><li>在站点文件夹下使用<code>hexo init</code>命令；</li><li>别忘了使用<code>npm install</code>来安装一些必要的组件；</li><li>现在可以通过<code>npm g &amp;&amp; npm s</code>来打开本地服务器，然后连接<code>http://localhost:4000/</code>来查看是否成功： <img src="/2020/05/10/blog-build/BlogBuild_2020-05-11-14-10-23.png" alt="页面效果"></li></ol><h2 id="博客部署至github">2. 博客部署至github</h2><ol type="1"><li><p>创建一个名为<code>luyiyun.github.io</code>的repository；</p></li><li><p>配置SSH key（为了不用每次都输密码）；</p></li><li><p>安装<code>hexo-deployer-git</code>插件，更改博客<code>_config.yml</code>文件，添加deploy项： <img src="/2020/05/10/blog-build/BlogBuild_2020-05-11-14-12-51.png" alt="添加deploy配置"></p></li><li><p>运行以下的命令：</p><div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1"></a><span class="ex">hexo</span> clean <span class="kw">&amp;&amp;</span> <span class="ex">hexo</span> g <span class="kw">&amp;&amp;</span> <span class="ex">hexo</span> d</span></code></pre></div><p>然后打开<code>luyiyun.github.io</code>，看是否部署成功： <img src="/2020/05/10/blog-build/BlogBuild_2020-05-11-14-19-05.png" alt="部署成功"></p></li></ol><p>以上在<a href="https://qinnian.xyz/CreateBlog.html" target="_blank" rel="noopener">钦の念</a>的博客中有更加详细的叙述。</p><h2 id="申请个人域名">2. 申请个人域名</h2><ol type="1"><li><p>申请一个新的域名<code>luyiyun.online</code>（腾讯云），别忘了添加一条解析记录使之能够正常解析；</p></li><li><p>在<code>/source</code>目录下，新建<code>CNAME</code>文件，然后写上域名，保存，然后<code>hexo g &amp;&amp; hexo d</code>部署；</p></li><li><p><code>CNAME</code>文件会被放到<code>public</code>中并一并上传到github上；</p></li><li><p>查看repository的settings，发现以下结果，代表可正常使用： <img src="/2020/05/10/blog-build/BlogBuild_2020-05-11-14-38-16.png" alt="个人域名配置成功"></p></li><li><p>可以使用这个域名来打开看看了： <img src="/2020/05/10/blog-build/BlogBuild_2020-05-11-14-39-38.png" alt="个人域名解析成功"></p></li></ol><h2 id="博客配置文件">3. 博客配置文件</h2><p>博客的配置文件是根目录下的<code>_config.yml</code>，现在我们对其中的内容依次进行处理：</p><ol type="1"><li><p>站点基本信息配置： <img src="/2020/05/10/blog-build/BlogBuild_2020-05-11-14-43-06.png" alt="site"></p></li><li><p>网站的url： <img src="/2020/05/10/blog-build/BlogBuild_2020-05-11-14-44-21.png" alt="url"></p></li><li><p>分页，设置这个是为了适配<a href="https://github.com/blinkfox/hexo-theme-matery.git" target="_blank" rel="noopener">hexo-theme-matery</a>： <img src="/2020/05/10/blog-build/BlogBuild_2020-05-11-14-46-33.png" alt="per_page"></p></li><li><p>主题，这里使用<a href="https://github.com/blinkfox/hexo-theme-matery.git" target="_blank" rel="noopener">hexo-theme-matery</a>： <img src="/2020/05/10/blog-build/BlogBuild_2020-05-11-14-48-13.png" alt="theme"></p><blockquote><p>我们在<code>/themes</code>文件夹下使用git来下载该主题：</p><div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1"></a><span class="fu">git</span> clone https://github.com/blinkfox/hexo-theme-matery.git</span></code></pre></div></blockquote></li><li><p>代码高亮，使用<code>hexo-prism-plugin</code>，并在<code>_config.yml</code>中加入以下内容： <img src="/2020/05/10/blog-build/BlogBuild_2020-05-11-17-50-24.png" alt="hightlight"></p><blockquote><p>前面有默认有<code>highlight: enable</code>的配置，所以这两个只保留一个即可。</p></blockquote></li><li><p>搜索，使用<code>hexo-generator-search</code>插件，并在配置文件中加入： <img src="/2020/05/10/blog-build/BlogBuild_2020-05-11-17-52-45.png" alt="search"></p></li><li><p>中文链接转拼音，使用<code>hexo-permalink-pinyin</code>： <img src="/2020/05/10/blog-build/BlogBuild_2020-05-11-17-54-47.png" alt="pinyin"></p></li><li><p>添加对<code>emoji</code>表情的支持，<code>hexo-filter-github-emojis</code> <img src="/2020/05/10/blog-build/BlogBuild_2020-05-11-17-56-43.png" alt="emoji"></p></li><li><p>添加RSS订阅支持，<code>hexo-generator-feed</code>， <img src="/2020/05/10/blog-build/BlogBuild_2020-05-11-17-58-22.png" alt="RSS"></p><p>出现下面情况，说明RSS配置成功： <img src="/2020/05/10/blog-build/BlogBuild_2020-05-11-18-12-25.png" alt="RSS-OK"></p></li><li><p>图片路径改为绝对路径，需要安装<code>hexo-asset-image</code>，并将<code>post_asset_folder</code>改为<code>true</code>。</p><blockquote><p>设置<code>_config.yml</code>中的<code>post_asset_folder: true</code>，这意味着使用<code>hexo new &lt;blog&gt;</code>时，在<code>_posts</code>中不只生成了一个md文件，而且还出现了一个同名文件夹，用来放md文件引用的内容。<del>我们可以在md文件中使用<code>![](name.jpg)</code>来引入图片。</del>但我们不会这样做，因为如此引入图片，在编写博客的时候是无法预览的，我们应该使用<code>![](&lt;blog&gt;/name.jpg)</code>的格式来引入。该插件使得我们就算这样引入图片，hexo也可以正确读取并处理它。</p></blockquote></li><li><p>安装<code>hexo-renderer-pandoc</code>，提供pandoc语法支持。</p></li><li><p>添加动漫人物，需要安装两个插件，并在根目录配置文件中添加下面的配置：</p><div class="sourceCode" id="cb5"><pre class="sourceCode yml"><code class="sourceCode yaml"><span id="cb5-1"><a href="#cb5-1"></a><span class="fu">live2d</span><span class="kw">:</span></span><span id="cb5-2"><a href="#cb5-2"></a><span class="at">    </span><span class="fu">enable</span><span class="kw">:</span><span class="at"> </span><span class="ch">true</span></span><span id="cb5-3"><a href="#cb5-3"></a><span class="at">    </span><span class="fu">scriptFrom</span><span class="kw">:</span><span class="at"> local</span></span><span id="cb5-4"><a href="#cb5-4"></a><span class="at">    </span><span class="fu">pluginRootPath</span><span class="kw">:</span><span class="at"> live2dw/</span></span><span id="cb5-5"><a href="#cb5-5"></a><span class="at">    </span><span class="fu">pluginJsPath</span><span class="kw">:</span><span class="at"> lib/</span></span><span id="cb5-6"><a href="#cb5-6"></a><span class="at">    </span><span class="fu">pluginModelPath</span><span class="kw">:</span><span class="at"> assets/</span></span><span id="cb5-7"><a href="#cb5-7"></a><span class="at">    </span><span class="fu">tagMode</span><span class="kw">:</span><span class="at"> </span><span class="ch">false</span></span><span id="cb5-8"><a href="#cb5-8"></a><span class="at">    </span><span class="fu">log</span><span class="kw">:</span><span class="at"> </span><span class="ch">false</span></span><span id="cb5-9"><a href="#cb5-9"></a><span class="at">    </span><span class="fu">model</span><span class="kw">:</span></span><span id="cb5-10"><a href="#cb5-10"></a><span class="at">        </span><span class="fu">use</span><span class="kw">:</span><span class="at"> live2d-widget-model-shizuku</span></span><span id="cb5-11"><a href="#cb5-11"></a><span class="at">    </span><span class="fu">display</span><span class="kw">:</span></span><span id="cb5-12"><a href="#cb5-12"></a><span class="at">        </span><span class="fu">position</span><span class="kw">:</span><span class="at"> right</span></span><span id="cb5-13"><a href="#cb5-13"></a><span class="at">        </span><span class="fu">width</span><span class="kw">:</span><span class="at"> </span><span class="dv">150</span></span><span id="cb5-14"><a href="#cb5-14"></a><span class="at">        </span><span class="fu">height</span><span class="kw">:</span><span class="at"> </span><span class="dv">300</span></span><span id="cb5-15"><a href="#cb5-15"></a><span class="at">    </span><span class="fu">mobile</span><span class="kw">:</span></span><span id="cb5-16"><a href="#cb5-16"></a><span class="at">        </span><span class="fu">show</span><span class="kw">:</span><span class="at"> </span><span class="ch">true</span></span><span id="cb5-17"><a href="#cb5-17"></a><span class="at">    </span><span class="fu">react</span><span class="kw">:</span></span><span id="cb5-18"><a href="#cb5-18"></a><span class="at">        </span><span class="fu">opacity</span><span class="kw">:</span><span class="at"> </span><span class="fl">0.7</span></span></code></pre></div></li><li><p>SEO配置</p><p>SEO（Search Engine Optimization），即搜索引擎优化：</p><blockquote><p>搜索引擎优化是一种通过了解搜索引擎的运作规则来调整网站，以及提高目的网站在有关搜索引擎内排名的方式。</p></blockquote><ol type="a"><li><p>验证网站。如果在谷歌搜索<code>site:luyiyun.online</code>查不到，这说明未被收录，则需要前往Google Search Console，进行验证： <img src="/2020/05/10/blog-build/BlogBuild_2020-05-11-18-53-12.png" alt="gsc"></p><p>方式和添加解析是一样，在腾讯云的控制台，添加DNS解析记录即可，其中记录值使用Google Search Console提供的值： <img src="/2020/05/10/blog-build/BlogBuild_2020-05-11-18-55-35.png" alt="gsc2"></p><p>等待几分钟后，在Google Search Console中进行验证，通过即可。</p></li><li><p>添加站点地图作用是告诉搜索引擎你的网站结构等信息，让搜索引擎更智能抓取内容。需要安装<code>hexo-generator-sitemap</code>插件，并在根目录的配置文件下添加： <img src="/2020/05/10/blog-build/BlogBuild_2020-05-11-18-59-19.png" alt="sitemap"></p></li><li><p>当<code>hexo g</code>后，public中出现了<code>sitemap.xml</code>文件。我们可以再进入Google Search Console，然后把这个站点地图（是这个sitemap文件）添加进去， <img src="/2020/05/10/blog-build/BlogBuild_2020-05-11-19-10-01.png" alt="sitemap2"></p></li><li><p>简化路径： <img src="/2020/05/10/blog-build/BlogBuild_2020-05-11-19-12-03.png" alt="path"></p></li></ol></li></ol><h2 id="新建主题文章模板">4. 新建主题文章模板</h2><p>建议将<code>/scaffolds/post.md</code>修改至：</p><div class="sourceCode" id="cb6"><pre class="sourceCode markdown"><code class="sourceCode markdown"><span id="cb6-1"><a href="#cb6-1"></a><span class="co">---</span></span><span id="cb6-2"><a href="#cb6-2"></a><span class="an">title:</span><span class="co"> Hexo博客搭建</span></span><span id="cb6-3"><a href="#cb6-3"></a><span class="an">date:</span><span class="co"> 1589105282000</span></span><span id="cb6-4"><a href="#cb6-4"></a><span class="an">author:</span><span class="co"> Lu Yiyun</span></span><span id="cb6-5"><a href="#cb6-5"></a><span class="an">img:</span><span class="co"> "文章特色图，空则hexo-theme-matery自动进行填补"</span></span><span id="cb6-6"><a href="#cb6-6"></a><span class="an">coverImg:</span><span class="co"> "文章在首页轮播封面时显示的图片，默认使用文章特色图"</span></span><span id="cb6-7"><a href="#cb6-7"></a><span class="an">top:</span><span class="co"> true</span></span><span id="cb6-8"><a href="#cb6-8"></a><span class="an">cover:</span><span class="co"> true</span></span><span id="cb6-9"><a href="#cb6-9"></a><span class="an">toc:</span><span class="co"> true</span></span><span id="cb6-10"><a href="#cb6-10"></a><span class="an">mathjax:</span><span class="co"> true</span></span><span id="cb6-11"><a href="#cb6-11"></a><span class="an">summary:</span><span class="co"> "自定义文章的摘要，不然自动从文章正文中吸取"</span></span><span id="cb6-12"><a href="#cb6-12"></a><span class="an">categories:</span></span><span id="cb6-13"><a href="#cb6-13"></a><span class="co">  - A</span></span><span id="cb6-14"><a href="#cb6-14"></a><span class="co">  - B</span></span><span id="cb6-15"><a href="#cb6-15"></a><span class="an">tags:</span></span><span id="cb6-16"><a href="#cb6-16"></a><span class="co">  - a</span></span><span id="cb6-17"><a href="#cb6-17"></a><span class="co">  - b</span></span><span id="cb6-18"><a href="#cb6-18"></a><span class="an">keywords:</span></span><span id="cb6-19"><a href="#cb6-19"></a><span class="co">---</span></span></code></pre></div><h2 id="新建工具页面">5. 新建工具页面</h2><div class="sourceCode" id="cb7"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1"></a><span class="ex">hexo</span> new page <span class="st">"categories"</span></span><span id="cb7-2"><a href="#cb7-2"></a><span class="ex">hexo</span> new page <span class="st">"tags"</span></span><span id="cb7-3"><a href="#cb7-3"></a><span class="ex">hexo</span> new page <span class="st">"about"</span></span><span id="cb7-4"><a href="#cb7-4"></a><span class="ex">hexo</span> new page <span class="st">"contact"</span></span><span id="cb7-5"><a href="#cb7-5"></a><span class="ex">hexo</span> new page <span class="st">"friends"</span></span></code></pre></div><p>并都将其中的<code>index.md</code>文件改写为以下格式：</p><pre><code>---title: categoriesdate: 2020-05-10 13:25:48type: "categories"layout: "categories"---</code></pre><p>然后手动再<code>/source/</code>下创建一个<code>404.md</code>，并填写一下内容：</p><div class="sourceCode" id="cb9"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1"></a><span class="ex">---</span></span><span id="cb9-2"><a href="#cb9-2"></a><span class="ex">title</span>: 404</span><span id="cb9-3"><a href="#cb9-3"></a><span class="ex">date</span>: 2019-07-19 16:41:10</span><span id="cb9-4"><a href="#cb9-4"></a><span class="ex">type</span>: <span class="st">"404"</span></span><span id="cb9-5"><a href="#cb9-5"></a><span class="ex">layout</span>: <span class="st">"404"</span></span><span id="cb9-6"><a href="#cb9-6"></a><span class="ex">description</span>: <span class="st">"你来到了没有知识的荒原 :("</span></span><span id="cb9-7"><a href="#cb9-7"></a><span class="ex">---</span></span></code></pre></div><p>并在<code>/themes/hexo-theme-matery/layout/</code>下新建<code>404.ejs</code>，并添加以下内容：</p><div class="sourceCode" id="cb10"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb10-1"><a href="#cb10-1"></a><span class="op">&lt;</span>style type<span class="op">=</span><span class="st">"text/css"</span><span class="op">&gt;</span></span><span id="cb10-2"><a href="#cb10-2"></a>    <span class="co">/* don't remove. */</span></span><span id="cb10-3"><a href="#cb10-3"></a>    <span class="op">.</span><span class="at">about</span><span class="op">-</span>cover {</span><span id="cb10-4"><a href="#cb10-4"></a>        <span class="dt">height</span><span class="op">:</span> 75vh<span class="op">;</span></span><span id="cb10-5"><a href="#cb10-5"></a>    }</span><span id="cb10-6"><a href="#cb10-6"></a><span class="op">&lt;/</span>style<span class="op">&gt;</span></span><span id="cb10-7"><a href="#cb10-7"></a></span><span id="cb10-8"><a href="#cb10-8"></a><span class="op">&lt;</span>div <span class="kw">class</span><span class="op">=</span><span class="st">"bg-cover pd-header about-cover"</span><span class="op">&gt;</span></span><span id="cb10-9"><a href="#cb10-9"></a>    <span class="op">&lt;</span>div <span class="kw">class</span><span class="op">=</span><span class="st">"container"</span><span class="op">&gt;</span></span><span id="cb10-10"><a href="#cb10-10"></a>        <span class="op">&lt;</span>div <span class="kw">class</span><span class="op">=</span><span class="st">"row"</span><span class="op">&gt;</span></span><span id="cb10-11"><a href="#cb10-11"></a>            <span class="op">&lt;</span>div <span class="kw">class</span><span class="op">=</span><span class="st">"col s10 offset-s1 m8 offset-m2 l8 offset-l2"</span><span class="op">&gt;</span></span><span id="cb10-12"><a href="#cb10-12"></a>                <span class="op">&lt;</span>div <span class="kw">class</span><span class="op">=</span><span class="st">"brand"</span><span class="op">&gt;</span></span><span id="cb10-13"><a href="#cb10-13"></a>                    <span class="op">&lt;</span>div <span class="kw">class</span><span class="op">=</span><span class="st">"title center-align"</span><span class="op">&gt;</span></span><span id="cb10-14"><a href="#cb10-14"></a>                        <span class="dv">404</span></span><span id="cb10-15"><a href="#cb10-15"></a>                    <span class="op">&lt;/</span>div<span class="op">&gt;</span></span><span id="cb10-16"><a href="#cb10-16"></a>                    <span class="op">&lt;</span>div <span class="kw">class</span><span class="op">=</span><span class="st">"description center-align"</span><span class="op">&gt;</span></span><span id="cb10-17"><a href="#cb10-17"></a>                        <span class="op">&lt;%=</span> page<span class="op">.</span><span class="at">description</span> <span class="op">%&gt;</span></span><span id="cb10-18"><a href="#cb10-18"></a>                    <span class="op">&lt;/</span>div<span class="op">&gt;</span></span><span id="cb10-19"><a href="#cb10-19"></a>                <span class="op">&lt;/</span>div<span class="op">&gt;</span></span><span id="cb10-20"><a href="#cb10-20"></a>            <span class="op">&lt;/</span>div<span class="op">&gt;</span></span><span id="cb10-21"><a href="#cb10-21"></a>        <span class="op">&lt;/</span>div<span class="op">&gt;</span></span><span id="cb10-22"><a href="#cb10-22"></a>    <span class="op">&lt;/</span>div<span class="op">&gt;</span></span><span id="cb10-23"><a href="#cb10-23"></a><span class="op">&lt;/</span>div<span class="op">&gt;</span></span><span id="cb10-24"><a href="#cb10-24"></a></span><span id="cb10-25"><a href="#cb10-25"></a><span class="op">&lt;</span>script<span class="op">&gt;</span></span><span id="cb10-26"><a href="#cb10-26"></a>    <span class="co">// 每天切换 banner 图.  Switch banner image every day.</span></span><span id="cb10-27"><a href="#cb10-27"></a>    $(<span class="st">'.bg-cover'</span>)<span class="op">.</span><span class="fu">css</span>(<span class="st">'background-image'</span><span class="op">,</span> <span class="st">'url(/medias/banner/'</span> <span class="op">+</span> <span class="kw">new</span> <span class="bu">Date</span>()<span class="op">.</span><span class="fu">getDay</span>() <span class="op">+</span> <span class="st">'.jpg)'</span>)<span class="op">;</span></span><span id="cb10-28"><a href="#cb10-28"></a><span class="op">&lt;/</span>script<span class="op">&gt;</span></span></code></pre></div><p>这样，我们就添加了一个404页面了。</p><h2 id="主题配置文件">6. 主题配置文件</h2><p>在<code>/themes/hexo-theme-matery</code>下有一个<code>_config.yml</code>文件，用来控制主题的诸多属性。</p><ol type="1"><li><p>第一部分配置菜单导航，icon可以在<a href="https://fontawesome.com/" target="_blank" rel="noopener">Font Awesome</a>中找： <img src="/2020/05/10/blog-build/BlogBuild_2020-05-11-15-18-16.png" alt="theme-menu"></p></li><li><p>站点运行时间： <img src="/2020/05/10/blog-build/BlogBuild_2020-05-11-15-21-03.png" alt="theme-start-time"></p></li><li><p>首页配置，包括封面轮播图、“梦想”和音乐： <img src="/2020/05/10/blog-build/BlogBuild_2020-05-11-15-23-59.png" alt="theme-index"></p></li><li><p>配置logo、favicon： <img src="/2020/05/10/blog-build/BlogBuild_2020-05-11-16-42-12.png" alt="theme-logo"></p></li><li><p>联系方式： <img src="/2020/05/10/blog-build/BlogBuild_2020-05-11-16-44-00.png" alt="theme-link"></p></li><li><p>文章目录设置： <img src="/2020/05/10/blog-build/BlogBuild_2020-05-11-16-45-03.png" alt="theme-toc"></p></li><li><p>代码块部分： <img src="/2020/05/10/blog-build/BlogBuild_2020-05-11-16-45-50.png" alt="theme-code-block"></p></li><li><p>打赏部分，记得替换为自己的二维码： <img src="/2020/05/10/blog-build/BlogBuild_2020-05-11-16-46-43.png" alt="theme-reward"></p></li><li><p>复制时追加版权信息： <img src="/2020/05/10/blog-build/BlogBuild_2020-05-11-16-48-45.png" alt="theme-copyright"></p></li><li><p>激活mathjax： <img src="/2020/05/10/blog-build/BlogBuild_2020-05-11-16-49-25.png" alt="theme-math"></p></li><li><p>开启文章信息，需要安装<code>hexo-wordcount</code>插件： <img src="/2020/05/10/blog-build/BlogBuild_2020-05-11-16-52-08.png" alt="theme-word"></p></li><li><p>"关于"页面的配置： <img src="/2020/05/10/blog-build/BlogBuild_2020-05-11-16-55-47.png" alt="theme-about"></p></li><li><p>评论配置，这里会开启两个评论：基于github issue的gitalk和无后端的valine：</p><ul><li><p>gitalk，安装相关插件<code>gitalk</code>：</p><ol type="a"><li><p>我们需要创建一个新的github repository来储存评论： <img src="/2020/05/10/blog-build/BlogBuild_2020-05-11-17-01-01.png" alt="theme-gitalk1"></p></li><li><p>开启issue功能（默认开启）： <img src="/2020/05/10/blog-build/BlogBuild_2020-05-11-17-02-49.png" alt="theme-gitalk2"></p></li><li><p>注册一个github application： <img src="/2020/05/10/blog-build/BlogBuild_2020-05-11-17-08-21.png" alt="theme-gitalk3"></p><p>并得到Client ID和Client Secret： <img src="/2020/05/10/blog-build/BlogBuild_2020-05-11-17-09-29.png" alt="theme-gitalk4"></p></li><li><p>将这些信息配置到<code>_config.yml</code>文件中： <img src="/2020/05/10/blog-build/BlogBuild_2020-05-11-17-12-25.png" alt="theme-gitalk5"></p></li><li><p>最终效果： <img src="/2020/05/10/blog-build/BlogBuild_2020-05-11-17-22-28.png" alt="theme-gitalk6"> <img src="/2020/05/10/blog-build/BlogBuild_2020-05-11-17-23-05.png" alt="theme-gitalk7"></p></li></ol></li><li><p><a href="https://valine.js.org/quickstart.html" target="_blank" rel="noopener">valine</a>，需要先安装插件<code>valine</code>：</p><ol type="a"><li><p>首先我们需要注册一个LeanCloud账户，并完成实名认证；</p></li><li><p>创建一个应用，然后找到其ID和Key： <img src="/2020/05/10/blog-build/BlogBuild_2020-05-11-17-31-24.png" alt="theme-valine1"></p></li><li><p>将这些信息配置到<code>_config.yml</code>文件中： <img src="/2020/05/10/blog-build/BlogBuild_2020-05-11-17-34-10.png" alt="theme-valine2"></p></li><li><p>效果： <img src="/2020/05/10/blog-build/BlogBuild_2020-05-11-17-36-40.png" alt="theme-valine3"></p></li><li><p>我们可以在LeanCloud中对这些评论进行管理： <img src="/2020/05/10/blog-build/BlogBuild_2020-05-11-17-38-10.png" alt="theme-valine4"></p></li></ol></li></ul></li></ol><h2 id="提高加载速度">7. 提高加载速度</h2><p>可以使用<a href="https://developers.google.com/speed/pagespeed/insights/" target="_blank" rel="noopener">Google PageSpeed Insights</a>来对网站的速度进行测试，并找到其瓶颈所在，其他的各种测速工具可以见<a href="https://qinnian.xyz/CreateBlog.html" target="_blank" rel="noopener">钦の念</a>的博客。</p><h3 id="图片懒加载">7.1 图片懒加载</h3><p>第一种可以提高速度的方式是进行图片的懒加载，安装<code>hexo-lazyload-image</code>，并在站点配置文件中加入：</p><div class="sourceCode" id="cb11"><pre class="sourceCode yml"><code class="sourceCode yaml"><span id="cb11-1"><a href="#cb11-1"></a><span class="fu">lazyload</span><span class="kw">:</span></span><span id="cb11-2"><a href="#cb11-2"></a><span class="fu">enable</span><span class="kw">:</span><span class="at"> </span><span class="ch">true</span></span><span id="cb11-3"><a href="#cb11-3"></a><span class="fu">onlypost</span><span class="kw">:</span><span class="at"> </span><span class="ch">false</span><span class="co">   # true则只会懒加载文章中的图片，logo头像什么的不会</span></span><span id="cb11-4"><a href="#cb11-4"></a><span class="fu">loadingImg</span><span class="kw">:</span><span class="at"> ./medias/loading.gif</span></span></code></pre></div><p><em>此插件与<code>hexo-asset-image</code>似乎不兼容，未解决。</em></p><h3 id="gitee和github双线部署">7.2 gitee和github双线部署</h3><p><em>未完待续...</em></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zsh及oh-my-zsh安装</title>
      <link href="/2020/05/10/zsh-an-zhuang/"/>
      <url>/2020/05/10/zsh-an-zhuang/</url>
      
        <content type="html"><![CDATA[<p>zsh以及oh-my-zsh除了可以提高终端的颜值，而且通过众多的插件可以提高我们的使用体验，所以这里将其安装和使用总结在这里，便于之后使用。</p><h1 id="zsh安装">zsh安装</h1><p><a href="http://zsh.sourceforge.net/" target="_blank" rel="noopener">zsh</a>是一个类似bash的shell，同样也是一个脚本语言集。</p><h2 id="包管理器安装">包管理器安装</h2><p>这就不多赘述了，如果是Ubuntu</p><pre><code>apt-get install zsh</code></pre><p>如果是centos</p><pre><code>yum install zsh -y</code></pre><p>oh-my-zsh给我们总结了所有平台安装zsh的方式：<a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Installing-ZSH" target="_blank" rel="noopener">Installing ZSH</a>，其中也介绍了如何把zsh设置为默认终端的流程。</p><h2 id="源码安装">源码安装</h2><p>如果我们没有root权限，或者希望将zsh安装到一个确定的目录下，则需要使用<a href="http://zsh.sourceforge.net/Arc/source.html" target="_blank" rel="noopener">源码</a>安装。</p><ol type="1"><li><p>下载源码包，然后是标准的CMMI（configure、make、make install）：</p><pre><code>mkdir buildcd build../configure --prefix=/path/to/zshmakemake install</code></pre></li><li><p>将zsh加入到环境变量中</p></li><li><p>将下列语句加入到<code>.bash_profile</code>中，使得自动载入zsh以及将zsh设置为默认的终端（如果zsh被安装在或其被链接到<code>$HOME/.local/bin/zsh</code>）：</p><pre><code>[ -f $HOME/.local/bin/zsh ] &amp;&amp; {    echo "Type Y to run zsh: \c"    read line    [ "$line" = Y ] &amp;&amp; {        export SHELL=$HOME/.local/bin/zsh        exec $HOME/.local/bin/zsh -l    }}</code></pre></li></ol><h1 id="oh-my-zsh安装">oh-my-zsh安装</h1><p><a href="https://ohmyz.sh/#install" target="_blank" rel="noopener">oh-my-zsh</a>是一个开源的zsh configure framewo，有好看的主题，有众多的插件来提高其功能。其<a href="https://ohmyz.sh/#install" target="_blank" rel="noopener">官网</a>中有安装的方式，这里我们使用下面稍加修改的模式：</p><div class="sourceCode" id="cb5"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1"></a><span class="co"># 可能下不下来，这时只能手动下载</span></span><span id="cb5-2"><a href="#cb5-2"></a><span class="fu">wget</span> https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh</span><span id="cb5-3"><a href="#cb5-3"></a><span class="va">ZSH=</span>/path/to/oh-my-zsh <span class="fu">sh</span> install.sh</span></code></pre></div><p><code>/path/to/oh-my-zsh</code>是自定义安装目录。</p><p>如果想要卸载oh-my-zsh，直接运行<code>uninstall_oh_my_zsh</code>即可。</p><h1 id="oh-my-zsh配置">oh-my-zsh配置</h1><h2 id="themes">themes</h2><p>设置主题，只需要在<code>.zshrc</code>中更改<code>ZSH_THEME</code>，然后<code>source .zshrc</code>即可。</p><p>oh-my-zsh本身就预装了大量的<a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Themes" target="_blank" rel="noopener">主题</a>，在<code>$ZSH/themes</code>中。另外，还有大量的<a href="https://github.com/ohmyzsh/ohmyzsh/wiki/External-themes" target="_blank" rel="noopener">额外主题</a>，但需要进行安装。</p><h2 id="plugins">plugins</h2><p>插件可以帮助我们更加有效率的工作，比如进行命令的提示、历史命令的记录等。本身oh-my-zsh也预装了大量的插件，<a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Plugins-Overview" target="_blank" rel="noopener">这里</a>是其插件列表。同样，我们也可以安装一些<a href="https://github.com/ohmyzsh/ohmyzsh/wiki/External-plugins" target="_blank" rel="noopener">第三方插件</a>。</p><p>插件启用的方式也是非常简单的，即在<code>.zshrc</code>中的<code>plugins=(...)</code>中添加我们想要的插件即可。</p><p>比如，这里我添加的:</p><ol type="1"><li><p><a href="https://github.com/zsh-users/zsh-autosuggestions/blob/master/INSTALL.md" target="_blank" rel="noopener"><code>zsh-autosuggestions</code></a>:</p><pre><code>git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions</code></pre><p>添加<code>zsh-autosuggestions</code>到<code>plugins=()</code>中。</p></li><li><p><a href="https://github.com/zsh-users/zsh-syntax-highlighting/blob/master/INSTALL.md" target="_blank" rel="noopener"><code>zsh-syntax-highlighting</code></a></p><pre><code>git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting</code></pre><p>添加<code>zsh-syntax-highlighting</code>到<code>plugins=()</code>中。</p></li><li><p>另外，我还添加了<code>pyenv</code>、<code>virtualenv</code>来显示虚拟环境下的python。</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zsh </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
